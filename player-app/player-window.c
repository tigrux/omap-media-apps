/* player-window.c generated by valac, the Vala compiler
 * generated from player-window.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <common.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <gst/gst.h>
#include <gst/interfaces/xoverlay.h>
#include <gdk/gdk.h>


#define TYPE_PLAYER_WINDOW (player_window_get_type ())
#define PLAYER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_WINDOW, PlayerWindow))
#define PLAYER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_WINDOW, PlayerWindowClass))
#define IS_PLAYER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_WINDOW))
#define IS_PLAYER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_WINDOW))
#define PLAYER_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_WINDOW, PlayerWindowClass))

typedef struct _PlayerWindow PlayerWindow;
typedef struct _PlayerWindowClass PlayerWindowClass;
typedef struct _PlayerWindowPrivate PlayerWindowPrivate;

#define TYPE_PLAY_LIST_CONTROL (play_list_control_get_type ())
#define PLAY_LIST_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAY_LIST_CONTROL, PlayListControl))
#define PLAY_LIST_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAY_LIST_CONTROL, PlayListControlClass))
#define IS_PLAY_LIST_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAY_LIST_CONTROL))
#define IS_PLAY_LIST_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAY_LIST_CONTROL))
#define PLAY_LIST_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAY_LIST_CONTROL, PlayListControlClass))

typedef struct _PlayListControl PlayListControl;
typedef struct _PlayListControlClass PlayListControlClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define __g_list_free_gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (_g_list_free_gtk_tree_path_free (var), NULL)))

struct _PlayerWindow {
	MediaWindow parent_instance;
	PlayerWindowPrivate * priv;
	GtkTreeView* playlist_view;
	GtkListStore* playlist_store;
	GtkTreeSelection* playlist_selection;
	PlayListControl* playlist_control;
	GtkToolButton* play_pause_button;
	GtkToolButton* add_button;
	GtkToolButton* next_button;
	GtkToolButton* fullscreen_button;
	GtkImage* remove_image;
	VideoArea* video_area;
	GtkScale* seeking_scale;
	GtkAdjustment* seeking_adjustment;
	GtkVolumeButton* volume_button;
	GtkAdjustment* volume_adjustment;
	GtkImage* mute_image;
	double previous_volume;
	char* muted_icon_name;
	gboolean is_muted;
	GtkFileChooserDialog* chooser;
	guint update_seeking_scale_id;
	gint64 stream_position;
	gint64 stream_duration;
	gboolean should_resume_playback;
	DebugDialog* debug_dialog;
};

struct _PlayerWindowClass {
	MediaWindowClass parent_class;
};


static gpointer player_window_parent_class = NULL;

#define TITLE "Omap4 Player"
#define ICON "omap4-player-app"
GType player_window_get_type (void);
GType play_list_control_get_type (void);
enum  {
	PLAYER_WINDOW_DUMMY_PROPERTY
};
void player_window_setup_model (PlayerWindow* self);
PlayListControl* play_list_control_new (GtkListStore* store);
PlayListControl* play_list_control_construct (GType object_type, GtkListStore* store);
void player_window_playlist_control_eos (PlayerWindow* self, GstObject* src);
static void _player_window_playlist_control_eos_media_control_eos_message (PlayListControl* _sender, GstObject* src, gpointer self);
void player_window_playlist_control_error (PlayerWindow* self, GstObject* src, GError* _error_, const char* debug);
static void _player_window_playlist_control_error_media_control_error_message (PlayListControl* _sender, GstObject* src, GError* _error_, const char* debug, gpointer self);
void player_window_playlist_control_playing (PlayerWindow* self, GtkTreeIter* iter);
static void _player_window_playlist_control_playing_play_list_control_playing (PlayListControl* _sender, GtkTreeIter* iter, gpointer self);
void player_window_playlist_control_paused (PlayerWindow* self, GtkTreeIter* iter);
static void _player_window_playlist_control_paused_play_list_control_paused (PlayListControl* _sender, GtkTreeIter* iter, gpointer self);
void player_window_playlist_control_stopped (PlayerWindow* self, GtkTreeIter* iter);
static void _player_window_playlist_control_stopped_play_list_control_stopped (PlayListControl* _sender, GtkTreeIter* iter, gpointer self);
void player_window_playlist_control_moved (PlayerWindow* self, GtkTreeIter* iter);
static void _player_window_playlist_control_moved_play_list_control_moved (PlayListControl* _sender, GtkTreeIter* iter, gpointer self);
void player_window_on_xid_prepared (PlayerWindow* self, GstXOverlay* imagesink);
static void _player_window_on_xid_prepared_media_control_prepare_xwindow_id (PlayListControl* _sender, GstXOverlay* imagesink, gpointer self);
void player_window_setup_controls (PlayerWindow* self);
void player_window_setup_toolbar (PlayerWindow* self);
void player_window_setup_notebook (PlayerWindow* self);
void player_window_setup_seeking (PlayerWindow* self);
void player_window_setup_widgets (PlayerWindow* self);
GtkBox* player_window_new_playlist_box (PlayerWindow* self);
GtkBox* player_window_new_video_box (PlayerWindow* self);
static void _lambda1_ (void* page, guint num_page, PlayerWindow* self);
static void __lambda1__gtk_notebook_switch_page (GtkNotebook* _sender, void* page, guint page_num, gpointer self);
void player_window_on_prev (PlayerWindow* self);
static void _player_window_on_prev_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
void player_window_play_pause (PlayerWindow* self);
static void _player_window_play_pause_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
void player_window_next (PlayerWindow* self);
static void _player_window_next_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
void player_window_stop (PlayerWindow* self);
static void _player_window_stop_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
GtkVolumeButton* player_window_new_volume_button_with_mute (PlayerWindow* self);
static void _media_window_toggle_fullscreen_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
void player_window_on_add (PlayerWindow* self);
static void _player_window_on_add_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
void player_window_on_remove (PlayerWindow* self);
static void _player_window_on_remove_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self);
gboolean player_window_on_seeking_scale_pressed (PlayerWindow* self);
static gboolean _player_window_on_seeking_scale_pressed_gtk_widget_button_press_event (GtkScale* _sender, GdkEventButton* event, gpointer self);
gboolean player_window_on_seeking_scale_released (PlayerWindow* self);
static gboolean _player_window_on_seeking_scale_released_gtk_widget_button_release_event (GtkScale* _sender, GdkEventButton* event, gpointer self);
char* player_window_on_scale_format_value (PlayerWindow* self, double scale_value);
static char* _player_window_on_scale_format_value_gtk_scale_format_value (GtkScale* _sender, double value, gpointer self);
gboolean player_window_is_playing (PlayerWindow* self);
gboolean play_list_control_play (PlayListControl* self);
void player_window_play (PlayerWindow* self);
gboolean play_list_control_pause (PlayListControl* self);
void player_window_pause (PlayerWindow* self);
gboolean play_list_control_stop (PlayListControl* self);
gboolean play_list_control_next (PlayListControl* self);
gboolean play_list_control_prev (PlayListControl* self);
void player_window_on_mute_clicked (PlayerWindow* self);
gboolean player_window_on_volume_button_pressed (PlayerWindow* self);
static gboolean _player_window_on_volume_button_pressed_gtk_widget_button_press_event (GtkVolumeButton* _sender, GdkEventButton* event, gpointer self);
static void _player_window_on_mute_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self);
void play_list_control_set_volume (PlayListControl* self, double value);
static void _lambda0_ (GtkAdjustment* volume, PlayerWindow* self);
static void __lambda0__gtk_adjustment_value_changed (GtkAdjustment* _sender, gpointer self);
double play_list_control_get_volume (PlayListControl* self);
GtkTreeView* player_window_new_playlist_view (PlayerWindow* self);
static void _media_window_toggle_fullscreen_video_area_activated (VideoArea* _sender, gpointer self);
void player_window_on_row_activated (PlayerWindow* self, GtkTreePath* row);
static void _player_window_on_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self);
gint play_list_control_get_icon_column (void);
gint play_list_control_get_name_column (void);
gboolean play_list_control_get_iter (PlayListControl* self, GtkTreeIter* iter);
gboolean play_list_control_move_to (PlayListControl* self, GtkTreePath* row);
gboolean player_window_get_and_select_iter (PlayerWindow* self, GtkTreeIter* iter);
char* play_list_control_iter_get_name (PlayListControl* self, GtkTreeIter* iter);
void player_window_add_update_scale_timeout (PlayerWindow* self);
void player_window_remove_update_scale_timeout (PlayerWindow* self);
void player_window_setup_chooser (PlayerWindow* self);
void player_window_on_chooser_response (PlayerWindow* self, gint response);
static void _player_window_on_chooser_response_gtk_dialog_response (GtkFileChooserDialog* _sender, gint response_id, gpointer self);
void play_list_control_add_file (PlayListControl* self, const char* file);
void player_window_on_remove_files (PlayerWindow* self);
static void _g_list_free_gtk_tree_path_free (GList* self);
gboolean player_window_update_scale_timeout (PlayerWindow* self);
static gboolean _player_window_update_scale_timeout_gsource_func (gpointer self);
void player_window_on_debug_dialog_closed (PlayerWindow* self);
static void _player_window_on_debug_dialog_closed_debug_dialog_closed (DebugDialog* _sender, gpointer self);
void player_window_setup_debug_dialog (PlayerWindow* self);
PlayerWindow* player_window_new (void);
PlayerWindow* player_window_construct (GType object_type);
static GObject * player_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void player_window_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);



void player_window_setup_model (PlayerWindow* self) {
	GType s;
	GtkListStore* _tmp0_;
	g_return_if_fail (self != NULL);
	s = G_TYPE_STRING;
	self->playlist_store = (_tmp0_ = gtk_list_store_new (3, s, s, s, NULL), _g_object_unref0 (self->playlist_store), _tmp0_);
}


static void _player_window_playlist_control_eos_media_control_eos_message (PlayListControl* _sender, GstObject* src, gpointer self) {
	player_window_playlist_control_eos (self, src);
}


static void _player_window_playlist_control_error_media_control_error_message (PlayListControl* _sender, GstObject* src, GError* _error_, const char* debug, gpointer self) {
	player_window_playlist_control_error (self, src, _error_, debug);
}


static void _player_window_playlist_control_playing_play_list_control_playing (PlayListControl* _sender, GtkTreeIter* iter, gpointer self) {
	player_window_playlist_control_playing (self, iter);
}


static void _player_window_playlist_control_paused_play_list_control_paused (PlayListControl* _sender, GtkTreeIter* iter, gpointer self) {
	player_window_playlist_control_paused (self, iter);
}


static void _player_window_playlist_control_stopped_play_list_control_stopped (PlayListControl* _sender, GtkTreeIter* iter, gpointer self) {
	player_window_playlist_control_stopped (self, iter);
}


static void _player_window_playlist_control_moved_play_list_control_moved (PlayListControl* _sender, GtkTreeIter* iter, gpointer self) {
	player_window_playlist_control_moved (self, iter);
}


static void _player_window_on_xid_prepared_media_control_prepare_xwindow_id (PlayListControl* _sender, GstXOverlay* imagesink, gpointer self) {
	player_window_on_xid_prepared (self, imagesink);
}


void player_window_setup_controls (PlayerWindow* self) {
	PlayListControl* _tmp0_;
	g_return_if_fail (self != NULL);
	self->playlist_control = (_tmp0_ = play_list_control_new (self->playlist_store), _g_object_unref0 (self->playlist_control), _tmp0_);
	g_signal_connect_object ((MediaControl*) self->playlist_control, "eos-message", (GCallback) _player_window_playlist_control_eos_media_control_eos_message, self, 0);
	g_signal_connect_object ((MediaControl*) self->playlist_control, "error-message", (GCallback) _player_window_playlist_control_error_media_control_error_message, self, 0);
	g_signal_connect_object (self->playlist_control, "playing", (GCallback) _player_window_playlist_control_playing_play_list_control_playing, self, 0);
	g_signal_connect_object (self->playlist_control, "paused", (GCallback) _player_window_playlist_control_paused_play_list_control_paused, self, 0);
	g_signal_connect_object (self->playlist_control, "stopped", (GCallback) _player_window_playlist_control_stopped_play_list_control_stopped, self, 0);
	g_signal_connect_object (self->playlist_control, "moved", (GCallback) _player_window_playlist_control_moved_play_list_control_moved, self, 0);
	g_signal_connect_object ((MediaControl*) self->playlist_control, "prepare-xwindow-id", (GCallback) _player_window_on_xid_prepared_media_control_prepare_xwindow_id, self, 0);
}


void player_window_setup_widgets (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_window_set_title ((GtkWindow*) self, TITLE);
	media_window_lookup_and_set_icon_name ((MediaWindow*) self, ICON);
	player_window_setup_toolbar (self);
	player_window_setup_notebook (self);
	player_window_setup_seeking (self);
	gtk_widget_realize ((GtkWidget*) self->video_area);
	gtk_widget_show_all ((GtkWidget*) ((MediaWindow*) self)->main_box);
}


static void _lambda1_ (void* page, guint num_page, PlayerWindow* self) {
	if (num_page == MEDIA_WINDOW_TAB_VIDEO) {
		gtk_widget_show ((GtkWidget*) self->fullscreen_button);
	} else {
		gtk_widget_hide ((GtkWidget*) self->fullscreen_button);
	}
}


static void __lambda1__gtk_notebook_switch_page (GtkNotebook* _sender, void* page, guint page_num, gpointer self) {
	_lambda1_ (page, page_num, self);
}


void player_window_setup_notebook (PlayerWindow* self) {
	GtkLabel* _tmp1_;
	GtkBox* _tmp0_;
	GtkLabel* _tmp3_;
	GtkBox* _tmp2_;
	g_return_if_fail (self != NULL);
	gtk_notebook_append_page (((MediaWindow*) self)->notebook, (GtkWidget*) (_tmp0_ = player_window_new_playlist_box (self)), (GtkWidget*) (_tmp1_ = g_object_ref_sink ((GtkLabel*) gtk_label_new ("List"))));
	_g_object_unref0 (_tmp1_);
	_g_object_unref0 (_tmp0_);
	gtk_notebook_append_page (((MediaWindow*) self)->notebook, (GtkWidget*) (_tmp2_ = player_window_new_video_box (self)), (GtkWidget*) (_tmp3_ = g_object_ref_sink ((GtkLabel*) gtk_label_new ("Video"))));
	_g_object_unref0 (_tmp3_);
	_g_object_unref0 (_tmp2_);
	g_signal_connect_object (((MediaWindow*) self)->notebook, "switch-page", (GCallback) __lambda1__gtk_notebook_switch_page, self, 0);
}


static void _player_window_on_prev_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	player_window_on_prev (self);
}


static void _player_window_play_pause_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	player_window_play_pause (self);
}


static void _player_window_next_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	player_window_next (self);
}


static void _player_window_stop_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	player_window_stop (self);
}


static void _media_window_toggle_fullscreen_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	media_window_toggle_fullscreen (self);
}


static void _player_window_on_add_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	player_window_on_add (self);
}


static void _player_window_on_remove_gtk_tool_button_clicked (GtkToolButton* _sender, gpointer self) {
	player_window_on_remove (self);
}


void player_window_setup_toolbar (PlayerWindow* self) {
	GtkToolButton* prev_button;
	GtkToolButton* _tmp0_;
	GtkToolButton* _tmp1_;
	GtkToolButton* stop_button;
	GtkToolItem* volume_button_item;
	GtkVolumeButton* _tmp2_;
	GtkToolButton* _tmp3_;
	GtkToolButton* _tmp4_;
	GtkToolButton* remove_button;
	g_return_if_fail (self != NULL);
	prev_button = g_object_ref_sink ((GtkToolButton*) gtk_tool_button_new_from_stock (GTK_STOCK_MEDIA_PREVIOUS));
	g_signal_connect_object (prev_button, "clicked", (GCallback) _player_window_on_prev_gtk_tool_button_clicked, self, 0);
	gtk_container_add ((GtkContainer*) ((MediaWindow*) self)->toolbar, (GtkWidget*) prev_button);
	self->play_pause_button = (_tmp0_ = g_object_ref_sink ((GtkToolButton*) gtk_tool_button_new_from_stock (GTK_STOCK_MEDIA_PLAY)), _g_object_unref0 (self->play_pause_button), _tmp0_);
	gtk_container_add ((GtkContainer*) ((MediaWindow*) self)->toolbar, (GtkWidget*) self->play_pause_button);
	g_signal_connect_object (self->play_pause_button, "clicked", (GCallback) _player_window_play_pause_gtk_tool_button_clicked, self, 0);
	self->next_button = (_tmp1_ = g_object_ref_sink ((GtkToolButton*) gtk_tool_button_new_from_stock (GTK_STOCK_MEDIA_NEXT)), _g_object_unref0 (self->next_button), _tmp1_);
	gtk_container_add ((GtkContainer*) ((MediaWindow*) self)->toolbar, (GtkWidget*) self->next_button);
	g_signal_connect_object (self->next_button, "clicked", (GCallback) _player_window_next_gtk_tool_button_clicked, self, 0);
	stop_button = g_object_ref_sink ((GtkToolButton*) gtk_tool_button_new_from_stock (GTK_STOCK_MEDIA_STOP));
	gtk_container_add ((GtkContainer*) ((MediaWindow*) self)->toolbar, (GtkWidget*) stop_button);
	g_signal_connect_object (stop_button, "clicked", (GCallback) _player_window_stop_gtk_tool_button_clicked, self, 0);
	media_window_toolbar_add_expander ((MediaWindow*) self);
	volume_button_item = g_object_ref_sink (gtk_tool_item_new ());
	gtk_container_add ((GtkContainer*) ((MediaWindow*) self)->toolbar, (GtkWidget*) volume_button_item);
	self->volume_button = (_tmp2_ = player_window_new_volume_button_with_mute (self), _g_object_unref0 (self->volume_button), _tmp2_);
	gtk_container_add ((GtkContainer*) volume_button_item, (GtkWidget*) self->volume_button);
	self->fullscreen_button = (_tmp3_ = g_object_ref_sink ((GtkToolButton*) gtk_tool_button_new_from_stock (GTK_STOCK_FULLSCREEN)), _g_object_unref0 (self->fullscreen_button), _tmp3_);
	gtk_widget_set_no_show_all ((GtkWidget*) self->fullscreen_button, TRUE);
	g_signal_connect_object (self->fullscreen_button, "clicked", (GCallback) _media_window_toggle_fullscreen_gtk_tool_button_clicked, (MediaWindow*) self, 0);
	gtk_container_add ((GtkContainer*) ((MediaWindow*) self)->toolbar, (GtkWidget*) self->fullscreen_button);
	media_window_toolbar_add_expander ((MediaWindow*) self);
	self->add_button = (_tmp4_ = g_object_ref_sink ((GtkToolButton*) gtk_tool_button_new_from_stock (GTK_STOCK_ADD)), _g_object_unref0 (self->add_button), _tmp4_);
	gtk_container_add ((GtkContainer*) ((MediaWindow*) self)->toolbar, (GtkWidget*) self->add_button);
	g_signal_connect_object (self->add_button, "clicked", (GCallback) _player_window_on_add_gtk_tool_button_clicked, self, 0);
	remove_button = g_object_ref_sink ((GtkToolButton*) gtk_tool_button_new_from_stock (GTK_STOCK_REMOVE));
	gtk_container_add ((GtkContainer*) ((MediaWindow*) self)->toolbar, (GtkWidget*) remove_button);
	g_signal_connect_object (remove_button, "clicked", (GCallback) _player_window_on_remove_gtk_tool_button_clicked, self, 0);
	media_window_toolbar_add_quit_button ((MediaWindow*) self);
	_g_object_unref0 (prev_button);
	_g_object_unref0 (stop_button);
	_g_object_unref0 (volume_button_item);
	_g_object_unref0 (remove_button);
}


static gboolean _player_window_on_seeking_scale_pressed_gtk_widget_button_press_event (GtkScale* _sender, GdkEventButton* event, gpointer self) {
	return player_window_on_seeking_scale_pressed (self);
}


static gboolean _player_window_on_seeking_scale_released_gtk_widget_button_release_event (GtkScale* _sender, GdkEventButton* event, gpointer self) {
	return player_window_on_seeking_scale_released (self);
}


static char* _player_window_on_scale_format_value_gtk_scale_format_value (GtkScale* _sender, double value, gpointer self) {
	return player_window_on_scale_format_value (self, value);
}


void player_window_setup_seeking (PlayerWindow* self) {
	GtkAdjustment* _tmp0_;
	GtkScale* _tmp1_;
	g_return_if_fail (self != NULL);
	self->seeking_adjustment = (_tmp0_ = g_object_ref_sink ((GtkAdjustment*) gtk_adjustment_new ((double) 0, (double) 0, (double) 100, 0.1, (double) 1, (double) 1)), _g_object_unref0 (self->seeking_adjustment), _tmp0_);
	self->seeking_scale = (_tmp1_ = (GtkScale*) g_object_ref_sink ((GtkHScale*) gtk_hscale_new (self->seeking_adjustment)), _g_object_unref0 (self->seeking_scale), _tmp1_);
	gtk_box_pack_start ((GtkBox*) ((MediaWindow*) self)->main_box, (GtkWidget*) self->seeking_scale, FALSE, FALSE, (guint) 0);
	gtk_widget_set_no_show_all ((GtkWidget*) self->seeking_scale, TRUE);
	gtk_range_set_update_policy ((GtkRange*) self->seeking_scale, GTK_UPDATE_DISCONTINUOUS);
	g_signal_connect_object ((GtkWidget*) self->seeking_scale, "button-press-event", (GCallback) _player_window_on_seeking_scale_pressed_gtk_widget_button_press_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self->seeking_scale, "button-release-event", (GCallback) _player_window_on_seeking_scale_released_gtk_widget_button_release_event, self, 0);
	g_signal_connect_object (self->seeking_scale, "format-value", (GCallback) _player_window_on_scale_format_value_gtk_scale_format_value, self, 0);
}


gboolean player_window_is_playing (PlayerWindow* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = media_control_get_state ((MediaControl*) self->playlist_control) == GST_STATE_PLAYING;
	return result;
}


void player_window_play (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	play_list_control_play (self->playlist_control);
}


void player_window_pause (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	play_list_control_pause (self->playlist_control);
}


void player_window_stop (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	play_list_control_stop (self->playlist_control);
}


void player_window_next (PlayerWindow* self) {
	gboolean was_playing;
	g_return_if_fail (self != NULL);
	was_playing = player_window_is_playing (self);
	if (play_list_control_next (self->playlist_control)) {
		if (was_playing) {
			player_window_play (self);
		}
	} else {
		GtkTreeIter iter = {0};
		if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->playlist_store, &iter)) {
			gtk_tree_selection_select_iter (self->playlist_selection, &iter);
		}
	}
}


void player_window_on_prev (PlayerWindow* self) {
	gboolean was_playing;
	g_return_if_fail (self != NULL);
	was_playing = player_window_is_playing (self);
	if (play_list_control_prev (self->playlist_control)) {
		if (was_playing) {
			player_window_play (self);
		}
	}
}


void player_window_on_xid_prepared (PlayerWindow* self, GstXOverlay* imagesink) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (imagesink != NULL);
	video_area_set_sink (self->video_area, imagesink);
	gtk_notebook_set_current_page (((MediaWindow*) self)->notebook, (gint) MEDIA_WINDOW_TAB_VIDEO);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void player_window_on_mute_clicked (PlayerWindow* self) {
	GtkAdjustment* volume;
	g_return_if_fail (self != NULL);
	volume = _g_object_ref0 (gtk_scale_button_get_adjustment ((GtkScaleButton*) self->volume_button));
	self->previous_volume = gtk_adjustment_get_value (volume);
	gtk_adjustment_set_value (volume, (double) 0);
	self->is_muted = TRUE;
	gtk_widget_hide (gtk_scale_button_get_popup ((GtkScaleButton*) self->volume_button));
	_g_object_unref0 (volume);
}


gboolean player_window_on_volume_button_pressed (PlayerWindow* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->is_muted) {
		GtkAdjustment* volume;
		volume = _g_object_ref0 (gtk_scale_button_get_adjustment ((GtkScaleButton*) self->volume_button));
		gtk_adjustment_set_value (volume, self->previous_volume);
		self->is_muted = FALSE;
		result = TRUE;
		_g_object_unref0 (volume);
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean _player_window_on_volume_button_pressed_gtk_widget_button_press_event (GtkVolumeButton* _sender, GdkEventButton* event, gpointer self) {
	return player_window_on_volume_button_pressed (self);
}


static void _player_window_on_mute_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_mute_clicked (self);
}


static void _lambda0_ (GtkAdjustment* volume, PlayerWindow* self) {
	g_return_if_fail (volume != NULL);
	play_list_control_set_volume (self->playlist_control, gtk_adjustment_get_value (volume));
}


static void __lambda0__gtk_adjustment_value_changed (GtkAdjustment* _sender, gpointer self) {
	_lambda0_ (_sender, self);
}


GtkVolumeButton* player_window_new_volume_button_with_mute (PlayerWindow* self) {
	GtkVolumeButton* result;
	GtkVolumeButton* volume_button;
	GtkIconSize icon_size;
	GtkWidget* _tmp0_;
	GtkWindow* popup_window;
	GtkWidget* _tmp1_;
	GtkFrame* popup_frame;
	GtkWidget* _tmp2_;
	GtkBox* popup_box;
	GtkButton* mute_button;
	char* _tmp5_;
	gint _tmp4__length1;
	char** _tmp4_;
	char** _tmp3_ = NULL;
	GtkImage* _tmp6_;
	GtkAdjustment* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	volume_button = g_object_ref_sink ((GtkVolumeButton*) gtk_volume_button_new ());
	icon_size = gtk_tool_shell_get_icon_size ((GtkToolShell*) ((MediaWindow*) self)->toolbar);
	g_object_set ((GtkScaleButton*) volume_button, "size", icon_size, NULL);
	g_signal_connect_object ((GtkWidget*) volume_button, "button-press-event", (GCallback) _player_window_on_volume_button_pressed_gtk_widget_button_press_event, self, 0);
	popup_window = _g_object_ref0 ((_tmp0_ = gtk_scale_button_get_popup ((GtkScaleButton*) volume_button), GTK_IS_WINDOW (_tmp0_) ? ((GtkWindow*) _tmp0_) : NULL));
	gtk_widget_set_size_request ((GtkWidget*) popup_window, -1, 240);
	popup_frame = _g_object_ref0 ((_tmp1_ = gtk_bin_get_child ((GtkBin*) popup_window), GTK_IS_FRAME (_tmp1_) ? ((GtkFrame*) _tmp1_) : NULL));
	popup_box = _g_object_ref0 ((_tmp2_ = gtk_bin_get_child ((GtkBin*) popup_frame), GTK_IS_BOX (_tmp2_) ? ((GtkBox*) _tmp2_) : NULL));
	gtk_box_set_spacing (popup_box, 24);
	gtk_container_remove ((GtkContainer*) popup_box, gtk_scale_button_get_plus_button ((GtkScaleButton*) volume_button));
	gtk_container_remove ((GtkContainer*) popup_box, gtk_scale_button_get_minus_button ((GtkScaleButton*) volume_button));
	mute_button = g_object_ref_sink ((GtkButton*) gtk_button_new ());
	gtk_box_pack_end (popup_box, (GtkWidget*) mute_button, FALSE, FALSE, (guint) 0);
	self->muted_icon_name = (_tmp5_ = g_strdup ((_tmp4_ = (g_object_get ((GtkScaleButton*) volume_button, "icons", &_tmp3_, NULL), _tmp3_), _tmp4__length1 = -1, _tmp4_)[0]), _g_free0 (self->muted_icon_name), _tmp5_);
	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
	self->mute_image = (_tmp6_ = g_object_ref_sink ((GtkImage*) gtk_image_new_from_icon_name (self->muted_icon_name, icon_size)), _g_object_unref0 (self->mute_image), _tmp6_);
	gtk_container_add ((GtkContainer*) mute_button, (GtkWidget*) self->mute_image);
	g_signal_connect_object (mute_button, "clicked", (GCallback) _player_window_on_mute_clicked_gtk_button_clicked, self, 0);
	gtk_widget_realize ((GtkWidget*) mute_button);
	self->volume_adjustment = (_tmp7_ = g_object_ref_sink ((GtkAdjustment*) gtk_adjustment_new ((double) 0, (double) 0, 1.0, 0.1, 0.1, (double) 0)), _g_object_unref0 (self->volume_adjustment), _tmp7_);
	gtk_scale_button_set_adjustment ((GtkScaleButton*) volume_button, self->volume_adjustment);
	g_signal_connect_object (self->volume_adjustment, "value-changed", (GCallback) __lambda0__gtk_adjustment_value_changed, self, 0);
	gtk_adjustment_set_value (self->volume_adjustment, play_list_control_get_volume (self->playlist_control));
	result = volume_button;
	_g_object_unref0 (popup_window);
	_g_object_unref0 (popup_frame);
	_g_object_unref0 (popup_box);
	_g_object_unref0 (mute_button);
	return result;
}


GtkBox* player_window_new_playlist_box (PlayerWindow* self) {
	GtkBox* result;
	GtkVBox* box;
	GtkScrolledWindow* scrolled_window;
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	box = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	scrolled_window = g_object_ref_sink ((GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL));
	gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) scrolled_window, TRUE, TRUE, (guint) 0);
	gtk_scrolled_window_set_policy (scrolled_window, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	self->playlist_view = (_tmp0_ = player_window_new_playlist_view (self), _g_object_unref0 (self->playlist_view), _tmp0_);
	gtk_container_add ((GtkContainer*) scrolled_window, (GtkWidget*) self->playlist_view);
	gtk_tree_view_set_model (self->playlist_view, (GtkTreeModel*) self->playlist_store);
	self->playlist_selection = (_tmp1_ = _g_object_ref0 (gtk_tree_view_get_selection (self->playlist_view)), _g_object_unref0 (self->playlist_selection), _tmp1_);
	gtk_tree_selection_set_mode (self->playlist_selection, GTK_SELECTION_BROWSE);
	result = (GtkBox*) box;
	_g_object_unref0 (scrolled_window);
	return result;
}


static void _media_window_toggle_fullscreen_video_area_activated (VideoArea* _sender, gpointer self) {
	media_window_toggle_fullscreen (self);
}


GtkBox* player_window_new_video_box (PlayerWindow* self) {
	GtkBox* result;
	GtkVBox* box;
	VideoArea* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	box = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	self->video_area = (_tmp0_ = g_object_ref_sink (video_area_new ()), _g_object_unref0 (self->video_area), _tmp0_);
	gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) self->video_area, TRUE, TRUE, (guint) 0);
	g_signal_connect_object (self->video_area, "activated", (GCallback) _media_window_toggle_fullscreen_video_area_activated, (MediaWindow*) self, 0);
	result = (GtkBox*) box;
	return result;
}


static void _player_window_on_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self) {
	player_window_on_row_activated (self, path);
}


GtkTreeView* player_window_new_playlist_view (PlayerWindow* self) {
	GtkTreeView* result;
	GtkTreeView* view;
	GtkCellRendererPixbuf* _tmp0_;
	GtkCellRendererText* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	view = g_object_ref_sink ((GtkTreeView*) gtk_tree_view_new ());
	gtk_tree_view_set_headers_visible (view, FALSE);
	g_signal_connect_object (view, "row-activated", (GCallback) _player_window_on_row_activated_gtk_tree_view_row_activated, self, 0);
	gtk_tree_view_insert_column_with_attributes (view, -1, "Icon", (GtkCellRenderer*) (_tmp0_ = g_object_ref_sink ((GtkCellRendererPixbuf*) gtk_cell_renderer_pixbuf_new ())), "stock-id", play_list_control_get_icon_column (), NULL, NULL);
	_g_object_unref0 (_tmp0_);
	gtk_tree_view_insert_column_with_attributes (view, -1, "Song", (GtkCellRenderer*) (_tmp1_ = g_object_ref_sink ((GtkCellRendererText*) gtk_cell_renderer_text_new ())), "markup", play_list_control_get_name_column (), NULL, NULL);
	_g_object_unref0 (_tmp1_);
	result = view;
	return result;
}


gboolean player_window_get_and_select_iter (PlayerWindow* self, GtkTreeIter* iter) {
	gboolean result;
	GtkTreePath* path;
	g_return_val_if_fail (self != NULL, FALSE);
	if (!gtk_tree_selection_get_selected (self->playlist_selection, NULL, iter)) {
		if (!play_list_control_get_iter (self->playlist_control, iter)) {
			if (!gtk_tree_model_get_iter_first ((GtkTreeModel*) self->playlist_store, iter)) {
				result = FALSE;
				return result;
			}
		}
	}
	path = gtk_tree_model_get_path ((GtkTreeModel*) self->playlist_store, iter);
	play_list_control_move_to (self->playlist_control, path);
	result = TRUE;
	_gtk_tree_path_free0 (path);
	return result;
}


void player_window_play_pause (PlayerWindow* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	switch (media_control_get_state ((MediaControl*) self->playlist_control)) {
		case GST_STATE_PLAYING:
		{
			{
				player_window_pause (self);
			}
			break;
		}
		case GST_STATE_PAUSED:
		{
			{
				player_window_play (self);
			}
			break;
		}
		case GST_STATE_NULL:
		{
			{
				GtkTreePath* row;
				if (!player_window_get_and_select_iter (self, &iter)) {
					return;
				}
				row = gtk_tree_model_get_path ((GtkTreeModel*) self->playlist_store, &iter);
				play_list_control_move_to (self->playlist_control, row);
				gtk_notebook_set_current_page (((MediaWindow*) self)->notebook, (gint) MEDIA_WINDOW_TAB_LIST);
				player_window_play (self);
				_gtk_tree_path_free0 (row);
			}
			break;
		}
	}
}


void player_window_playlist_control_playing (PlayerWindow* self, GtkTreeIter* iter) {
	char* _tmp0_;
	g_return_if_fail (self != NULL);
	gtk_window_set_title ((GtkWindow*) self, _tmp0_ = play_list_control_iter_get_name (self->playlist_control, iter));
	_g_free0 (_tmp0_);
	gtk_tool_button_set_stock_id (self->play_pause_button, GTK_STOCK_MEDIA_PAUSE);
	player_window_add_update_scale_timeout (self);
	gtk_widget_show ((GtkWidget*) self->seeking_scale);
}


void player_window_playlist_control_paused (PlayerWindow* self, GtkTreeIter* iter) {
	g_return_if_fail (self != NULL);
	gtk_tool_button_set_stock_id (self->play_pause_button, GTK_STOCK_MEDIA_PLAY);
	player_window_remove_update_scale_timeout (self);
}


void player_window_playlist_control_stopped (PlayerWindow* self, GtkTreeIter* iter) {
	gint page;
	g_return_if_fail (self != NULL);
	gtk_window_set_title ((GtkWindow*) self, TITLE);
	page = gtk_notebook_get_current_page (((MediaWindow*) self)->notebook);
	if (page != MEDIA_WINDOW_TAB_LIST) {
		gtk_notebook_set_current_page (((MediaWindow*) self)->notebook, (gint) MEDIA_WINDOW_TAB_LIST);
	}
	gtk_tool_button_set_stock_id (self->play_pause_button, GTK_STOCK_MEDIA_PLAY);
	player_window_remove_update_scale_timeout (self);
	gtk_widget_hide ((GtkWidget*) self->seeking_scale);
}


void player_window_playlist_control_moved (PlayerWindow* self, GtkTreeIter* iter) {
	g_return_if_fail (self != NULL);
	gtk_tree_selection_select_iter (self->playlist_selection, iter);
}


void player_window_on_add (PlayerWindow* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	player_window_setup_chooser (self);
	gtk_widget_show ((GtkWidget*) self->chooser);
	gtk_dialog_run ((GtkDialog*) self->chooser);
	player_window_get_and_select_iter (self, &iter);
}


static void _player_window_on_chooser_response_gtk_dialog_response (GtkFileChooserDialog* _sender, gint response_id, gpointer self) {
	player_window_on_chooser_response (self, response_id);
}


void player_window_setup_chooser (PlayerWindow* self) {
	GtkFileChooserDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	if (self->chooser != NULL) {
		return;
	}
	self->chooser = (_tmp0_ = g_object_ref_sink ((GtkFileChooserDialog*) gtk_file_chooser_dialog_new ("Add files to playlist", (GtkWindow*) self, GTK_FILE_CHOOSER_ACTION_OPEN, GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE, GTK_STOCK_ADD, GTK_RESPONSE_OK, NULL, NULL)), _g_object_unref0 (self->chooser), _tmp0_);
	g_signal_connect_object ((GtkDialog*) self->chooser, "response", (GCallback) _player_window_on_chooser_response_gtk_dialog_response, self, 0);
}


void player_window_on_chooser_response (PlayerWindow* self, gint response) {
	g_return_if_fail (self != NULL);
	switch (response) {
		case GTK_RESPONSE_CLOSE:
		{
			{
				gtk_widget_hide ((GtkWidget*) self->chooser);
			}
			break;
		}
		case GTK_RESPONSE_OK:
		{
			{
				char* _tmp0_;
				play_list_control_add_file (self->playlist_control, _tmp0_ = gtk_file_chooser_get_filename ((GtkFileChooser*) self->chooser));
				_g_free0 (_tmp0_);
			}
			break;
		}
	}
}


void player_window_on_remove (PlayerWindow* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	player_window_on_remove_files (self);
	player_window_get_and_select_iter (self, &iter);
}


static void _g_list_free_gtk_tree_path_free (GList* self) {
	g_list_foreach (self, (GFunc) gtk_tree_path_free, NULL);
	g_list_free (self);
}


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


void player_window_on_remove_files (PlayerWindow* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	{
		GList* row_collection;
		GList* row_it;
		row_collection = gtk_tree_selection_get_selected_rows (self->playlist_selection, NULL);
		for (row_it = row_collection; row_it != NULL; row_it = row_it->next) {
			GtkTreePath* row;
			row = _gtk_tree_path_copy0 ((GtkTreePath*) row_it->data);
			{
				gtk_tree_model_get_iter ((GtkTreeModel*) self->playlist_store, &iter, row);
				gtk_list_store_remove (self->playlist_store, &iter);
				_gtk_tree_path_free0 (row);
			}
		}
		__g_list_free_gtk_tree_path_free0 (row_collection);
	}
}


void player_window_on_row_activated (PlayerWindow* self, GtkTreePath* row) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (row != NULL);
	player_window_stop (self);
	if (play_list_control_move_to (self->playlist_control, row)) {
		player_window_play (self);
	}
}


gboolean player_window_on_seeking_scale_pressed (PlayerWindow* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	if (player_window_is_playing (self)) {
		player_window_pause (self);
		self->should_resume_playback = TRUE;
	} else {
		self->should_resume_playback = FALSE;
	}
	result = FALSE;
	return result;
}


gboolean player_window_on_seeking_scale_released (PlayerWindow* self) {
	gboolean result;
	gint64 real_value = 0LL;
	g_return_val_if_fail (self != NULL, FALSE);
	real_value = (gint64) ((gtk_range_get_value ((GtkRange*) self->seeking_scale) * self->stream_duration) / 100);
	media_control_set_position ((MediaControl*) self->playlist_control, real_value);
	if (self->should_resume_playback) {
		player_window_play (self);
	}
	result = FALSE;
	return result;
}


char* player_window_on_scale_format_value (PlayerWindow* self, double scale_value) {
	char* result;
	double real_value = 0.0;
	double real_duration = 0.0;
	gint sec0;
	gint sec1;
	g_return_val_if_fail (self != NULL, NULL);
	if (self->stream_duration == (-1)) {
		real_value = (double) 0;
		real_duration = (double) 0;
	} else {
		real_value = (scale_value * self->stream_duration) / 100.0;
		real_duration = (double) self->stream_duration;
	}
	sec0 = (gint) (real_value / GST_SECOND);
	sec1 = (gint) (real_duration / GST_SECOND);
	result = g_strdup_printf ("%02d:%02d/%02d:%02d", sec0 / 60, sec0 % 60, sec1 / 60, sec1 % 60);
	return result;
}


static gboolean _player_window_update_scale_timeout_gsource_func (gpointer self) {
	return player_window_update_scale_timeout (self);
}


void player_window_add_update_scale_timeout (PlayerWindow* self) {
	guint timeout_id;
	g_return_if_fail (self != NULL);
	if (self->update_seeking_scale_id != 0) {
		return;
	}
	timeout_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 500, _player_window_update_scale_timeout_gsource_func, g_object_ref (self), g_object_unref);
	self->update_seeking_scale_id = timeout_id;
}


void player_window_remove_update_scale_timeout (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	if (self->update_seeking_scale_id == 0) {
		return;
	}
	g_source_remove (self->update_seeking_scale_id);
	self->update_seeking_scale_id = (guint) 0;
}


gboolean player_window_update_scale_timeout (PlayerWindow* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	self->stream_position = media_control_get_position ((MediaControl*) self->playlist_control);
	self->stream_duration = media_control_get_duration ((MediaControl*) self->playlist_control);
	if (self->stream_position >= 0) {
		_tmp0_ = self->stream_duration > 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		double stream_value;
		stream_value = (self->stream_position * 100.0) / self->stream_duration;
		gtk_adjustment_set_value (self->seeking_adjustment, stream_value);
	}
	result = TRUE;
	return result;
}


static void _player_window_on_debug_dialog_closed_debug_dialog_closed (DebugDialog* _sender, gpointer self) {
	player_window_on_debug_dialog_closed (self);
}


void player_window_setup_debug_dialog (PlayerWindow* self) {
	DebugDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	if (self->debug_dialog != NULL) {
		return;
	}
	gtk_widget_hide ((GtkWidget*) self->seeking_scale);
	gtk_widget_hide ((GtkWidget*) ((MediaWindow*) self)->toolbar);
	self->debug_dialog = (_tmp0_ = g_object_ref_sink (debug_dialog_new ((GtkWindow*) self)), _g_object_unref0 (self->debug_dialog), _tmp0_);
	g_signal_connect_object (self->debug_dialog, "closed", (GCallback) _player_window_on_debug_dialog_closed_debug_dialog_closed, self, 0);
	gtk_widget_show ((GtkWidget*) self->debug_dialog);
}


void player_window_on_debug_dialog_closed (PlayerWindow* self) {
	DebugDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	gtk_widget_show ((GtkWidget*) ((MediaWindow*) self)->toolbar);
	player_window_stop (self);
	self->debug_dialog = (_tmp0_ = NULL, _g_object_unref0 (self->debug_dialog), _tmp0_);
}


void player_window_playlist_control_eos (PlayerWindow* self, GstObject* src) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (src != NULL);
	gtk_widget_activate ((GtkWidget*) self->next_button);
}


void player_window_playlist_control_error (PlayerWindow* self, GstObject* src, GError* _error_, const char* debug) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (src != NULL);
	g_return_if_fail (debug != NULL);
	player_window_setup_debug_dialog (self);
	debug_dialog_add_error_debug (self->debug_dialog, _error_, debug);
}


PlayerWindow* player_window_construct (GType object_type) {
	PlayerWindow * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


PlayerWindow* player_window_new (void) {
	return player_window_construct (TYPE_PLAYER_WINDOW);
}


static GObject * player_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	PlayerWindow * self;
	parent_class = G_OBJECT_CLASS (player_window_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = PLAYER_WINDOW (obj);
	{
		player_window_setup_model (self);
		player_window_setup_controls (self);
		player_window_setup_widgets (self);
	}
	return obj;
}


static void player_window_class_init (PlayerWindowClass * klass) {
	player_window_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = player_window_constructor;
	G_OBJECT_CLASS (klass)->finalize = player_window_finalize;
}


static void player_window_instance_init (PlayerWindow * self) {
}


static void player_window_finalize (GObject* obj) {
	PlayerWindow * self;
	self = PLAYER_WINDOW (obj);
	_g_object_unref0 (self->playlist_view);
	_g_object_unref0 (self->playlist_store);
	_g_object_unref0 (self->playlist_selection);
	_g_object_unref0 (self->playlist_control);
	_g_object_unref0 (self->play_pause_button);
	_g_object_unref0 (self->add_button);
	_g_object_unref0 (self->next_button);
	_g_object_unref0 (self->fullscreen_button);
	_g_object_unref0 (self->remove_image);
	_g_object_unref0 (self->video_area);
	_g_object_unref0 (self->seeking_scale);
	_g_object_unref0 (self->seeking_adjustment);
	_g_object_unref0 (self->volume_button);
	_g_object_unref0 (self->volume_adjustment);
	_g_object_unref0 (self->mute_image);
	_g_free0 (self->muted_icon_name);
	_g_object_unref0 (self->chooser);
	_g_object_unref0 (self->debug_dialog);
	G_OBJECT_CLASS (player_window_parent_class)->finalize (obj);
}


GType player_window_get_type (void) {
	static GType player_window_type_id = 0;
	if (player_window_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (PlayerWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlayerWindow), 0, (GInstanceInitFunc) player_window_instance_init, NULL };
		player_window_type_id = g_type_register_static (TYPE_MEDIA_WINDOW, "PlayerWindow", &g_define_type_info, 0);
	}
	return player_window_type_id;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}




