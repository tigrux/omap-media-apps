/* player-window.c generated by valac, the Vala compiler
 * generated from player-window.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <gst/gst.h>


#define TYPE_PLAY_LIST_COL (play_list_col_get_type ())

#define TYPE_PLAYER_TAB (player_tab_get_type ())

#define TYPE_PLAYER_WINDOW (player_window_get_type ())
#define PLAYER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_WINDOW, PlayerWindow))
#define PLAYER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_WINDOW, PlayerWindowClass))
#define IS_PLAYER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_WINDOW))
#define IS_PLAYER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_WINDOW))
#define PLAYER_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_WINDOW, PlayerWindowClass))

typedef struct _PlayerWindow PlayerWindow;
typedef struct _PlayerWindowClass PlayerWindowClass;
typedef struct _PlayerWindowPrivate PlayerWindowPrivate;

#define TYPE_PLAY_LIST_CONTROL (play_list_control_get_type ())
#define PLAY_LIST_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAY_LIST_CONTROL, PlayListControl))
#define PLAY_LIST_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAY_LIST_CONTROL, PlayListControlClass))
#define IS_PLAY_LIST_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAY_LIST_CONTROL))
#define IS_PLAY_LIST_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAY_LIST_CONTROL))
#define PLAY_LIST_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAY_LIST_CONTROL, PlayListControlClass))

typedef struct _PlayListControl PlayListControl;
typedef struct _PlayListControlClass PlayListControlClass;

#define TYPE_VIDEO_AREA (video_area_get_type ())
#define VIDEO_AREA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_VIDEO_AREA, VideoArea))
#define VIDEO_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_VIDEO_AREA, VideoAreaClass))
#define IS_VIDEO_AREA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_VIDEO_AREA))
#define IS_VIDEO_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_VIDEO_AREA))
#define VIDEO_AREA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_VIDEO_AREA, VideoAreaClass))

typedef struct _VideoArea VideoArea;
typedef struct _VideoAreaClass VideoAreaClass;

#define TYPE_DEBUG_DIALOG (debug_dialog_get_type ())
#define DEBUG_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEBUG_DIALOG, DebugDialog))
#define DEBUG_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEBUG_DIALOG, DebugDialogClass))
#define IS_DEBUG_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEBUG_DIALOG))
#define IS_DEBUG_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEBUG_DIALOG))
#define DEBUG_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEBUG_DIALOG, DebugDialogClass))

typedef struct _DebugDialog DebugDialog;
typedef struct _DebugDialogClass DebugDialogClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_CONTROL (control_get_type ())
#define CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONTROL, Control))
#define IS_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONTROL))
#define CONTROL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_CONTROL, ControlIface))

typedef struct _Control Control;
typedef struct _ControlIface ControlIface;
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define __g_list_free_gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (_g_list_free_gtk_tree_path_free (var), NULL)))

typedef enum  {
	PLAY_LIST_COL_ICON,
	PLAY_LIST_COL_NAME,
	PLAY_LIST_COL_FULLNAME
} PlayListCol;

typedef enum  {
	PLAYER_TAB_LIST,
	PLAYER_TAB_VIDEO
} PlayerTab;

struct _PlayerWindow {
	GtkWindow parent_instance;
	PlayerWindowPrivate * priv;
	GtkTreeView* playlist_view;
	GtkListStore* playlist_store;
	GtkTreeSelection* playlist_selection;
	PlayListControl* playlist_control;
	GtkBox* controls_box;
	GtkNotebook* notebook;
	GtkButton* add_button;
	GtkButton* next_button;
	GtkImage* play_pause_image;
	GtkImage* remove_close_image;
	GtkImage* remove_image;
	VideoArea* video_area;
	GtkScale* seeking_scale;
	GtkAdjustment* seeking_adjustment;
	GtkVolumeButton* volume_button;
	GtkAdjustment* volume_adjustment;
	GtkImage* mute_image;
	double previous_volume;
	char* muted_icon_name;
	gboolean is_muted;
	GtkFileChooserDialog* chooser;
	guint update_seeking_scale_id;
	gint64 stream_position;
	gint64 stream_duration;
	gboolean should_resume_playback;
	gboolean is_fullscreen;
	DebugDialog* debug_dialog;
};

struct _PlayerWindowClass {
	GtkWindowClass parent_class;
};

struct _ControlIface {
	GTypeInterface parent_iface;
	GstBus* (*get_bus) (Control* self);
};


static gpointer player_window_parent_class = NULL;

GType play_list_col_get_type (void);
GType player_tab_get_type (void);
#define UPDATE_INTERVAL ((guint) 200)
#define TITLE "PlayerApp"
GType player_window_get_type (void);
GType play_list_control_get_type (void);
GType video_area_get_type (void);
GType debug_dialog_get_type (void);
enum  {
	PLAYER_WINDOW_DUMMY_PROPERTY
};
PlayListControl* play_list_control_new (GtkListStore* store);
PlayListControl* play_list_control_construct (GType object_type, GtkListStore* store);
void player_window_on_playlist_control_eos (PlayerWindow* self);
static void _player_window_on_playlist_control_eos_play_list_control_eos (PlayListControl* _sender, gpointer self);
void player_window_on_playlist_control_error (PlayerWindow* self, GError* _error_, const char* debug);
static void _player_window_on_playlist_control_error_play_list_control_error (PlayListControl* _sender, GError* e, const char* debug, gpointer self);
void player_window_on_playlist_control_playing (PlayerWindow* self, GtkTreeIter* iter);
static void _player_window_on_playlist_control_playing_play_list_control_playing (PlayListControl* _sender, GtkTreeIter* iter, gpointer self);
void player_window_on_playlist_control_paused (PlayerWindow* self, GtkTreeIter* iter);
static void _player_window_on_playlist_control_paused_play_list_control_paused (PlayListControl* _sender, GtkTreeIter* iter, gpointer self);
void player_window_on_playlist_control_stopped (PlayerWindow* self, GtkTreeIter* iter);
static void _player_window_on_playlist_control_stopped_play_list_control_stopped (PlayListControl* _sender, GtkTreeIter* iter, gpointer self);
void player_window_on_playlist_control_moved (PlayerWindow* self, GtkTreeIter* iter);
static void _player_window_on_playlist_control_moved_play_list_control_moved (PlayListControl* _sender, GtkTreeIter* iter, gpointer self);
void player_window_setup_elements (PlayerWindow* self);
#define DEFAULT_WIDTH 800
#define DEFAULT_HEIGHT 480
gboolean player_window_on_delete (PlayerWindow* self);
static gboolean _player_window_on_delete_gtk_widget_delete_event (PlayerWindow* _sender, GdkEvent* event, gpointer self);
GtkButtonBox* player_window_new_buttons_box (PlayerWindow* self);
GtkBox* player_window_new_playlist_box (PlayerWindow* self);
GtkBox* player_window_new_video_box (PlayerWindow* self);
static gboolean _lambda5_ (gint page, PlayerWindow* self);
static gboolean __lambda5__gtk_notebook_change_current_page (GtkNotebook* _sender, gint offset, gpointer self);
gboolean player_window_on_seeking_scale_pressed (PlayerWindow* self);
static gboolean _player_window_on_seeking_scale_pressed_gtk_widget_button_press_event (GtkScale* _sender, GdkEventButton* event, gpointer self);
gboolean player_window_on_seeking_scale_released (PlayerWindow* self);
static gboolean _player_window_on_seeking_scale_released_gtk_widget_button_release_event (GtkScale* _sender, GdkEventButton* event, gpointer self);
char* player_window_on_scale_format_value (PlayerWindow* self, double scale_value);
static char* _player_window_on_scale_format_value_gtk_scale_format_value (GtkScale* _sender, double value, gpointer self);
void player_window_setup_widgets (PlayerWindow* self);
GstState play_list_control_get_state (PlayListControl* self);
gboolean player_window_is_playing (PlayerWindow* self);
gboolean play_list_control_play (PlayListControl* self);
void player_window_on_play (PlayerWindow* self);
gboolean play_list_control_pause (PlayListControl* self);
void player_window_on_pause (PlayerWindow* self);
gboolean play_list_control_stop (PlayListControl* self);
void player_window_on_stop (PlayerWindow* self);
gboolean play_list_control_next (PlayListControl* self);
void player_window_on_next (PlayerWindow* self);
gboolean play_list_control_prev (PlayListControl* self);
void player_window_on_prev (PlayerWindow* self);
static gboolean _player_window_on_delete_gsource_func (gpointer self);
void player_window_on_quit (PlayerWindow* self);
GtkButton* new_button_with_stock_image (const char* stock_id);
void player_window_on_play_pause (PlayerWindow* self);
static void _player_window_on_play_pause_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void _player_window_on_stop_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void _player_window_on_prev_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void _player_window_on_next_gtk_button_clicked (GtkButton* _sender, gpointer self);
void player_window_on_add (PlayerWindow* self);
static void _player_window_on_add_gtk_button_clicked (GtkButton* _sender, gpointer self);
void player_window_on_remove (PlayerWindow* self);
static void _player_window_on_remove_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void _player_window_on_quit_gtk_button_clicked (GtkButton* _sender, gpointer self);
GtkVolumeButton* player_window_new_volume_button_with_mute (PlayerWindow* self);
void player_window_on_mute_clicked (PlayerWindow* self);
gboolean player_window_on_volume_button_pressed (PlayerWindow* self);
#define ICON_SIZE GTK_ICON_SIZE_DND
static gboolean _player_window_on_volume_button_pressed_gtk_widget_button_press_event (GtkVolumeButton* _sender, GdkEventButton* event, gpointer self);
static void _player_window_on_mute_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self);
void play_list_control_set_volume (PlayListControl* self, double value);
static void _lambda3_ (GtkAdjustment* volume, PlayerWindow* self);
static void __lambda3__gtk_adjustment_value_changed (GtkAdjustment* _sender, gpointer self);
double play_list_control_get_volume (PlayListControl* self);
GtkTreeView* player_window_new_playlist_view (PlayerWindow* self);
VideoArea* video_area_new (void);
VideoArea* video_area_construct (GType object_type);
void player_window_on_video_area_activated (PlayerWindow* self);
static void _player_window_on_video_area_activated_video_area_activated (VideoArea* _sender, gpointer self);
static void _lambda4_ (PlayerWindow* self);
static void __lambda4__video_area_prepared (VideoArea* _sender, gpointer self);
GType control_get_type (void);
void video_area_set_control (VideoArea* self, Control* control);
void player_window_on_row_activated (PlayerWindow* self, GtkTreePath* row);
static void _player_window_on_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self);
GtkListStore* player_window_new_playlist_store (PlayerWindow* self);
gboolean play_list_control_get_iter (PlayListControl* self, GtkTreeIter* iter);
gboolean play_list_control_move_to (PlayListControl* self, GtkTreePath* row);
gboolean player_window_get_and_select_iter (PlayerWindow* self, GtkTreeIter* iter);
void player_window_add_update_scale_timeout (PlayerWindow* self);
void player_window_remove_update_scale_timeout (PlayerWindow* self);
void player_window_setup_chooser (PlayerWindow* self);
void player_window_on_chooser_response (PlayerWindow* self, gint response);
static void _player_window_on_chooser_response_gtk_dialog_response (GtkFileChooserDialog* _sender, gint response_id, gpointer self);
void play_list_control_add_file (PlayListControl* self, const char* file);
void player_window_on_remove_files (PlayerWindow* self);
static void _g_list_free_gtk_tree_path_free (GList* self);
void play_list_control_seek (PlayListControl* self, gint64 location);
gboolean player_window_update_scale_timeout (PlayerWindow* self);
static gboolean _player_window_update_scale_timeout_gsource_func (gpointer self);
gint64 play_list_control_get_position (PlayListControl* self);
gint64 play_list_control_get_duration (PlayListControl* self);
DebugDialog* debug_dialog_new (GtkWindow* parent);
DebugDialog* debug_dialog_construct (GType object_type, GtkWindow* parent);
void player_window_on_debug_dialog_closed (PlayerWindow* self);
static void _player_window_on_debug_dialog_closed_debug_dialog_closed (DebugDialog* _sender, gpointer self);
void player_window_setup_debug_dialog (PlayerWindow* self);
void debug_dialog_add_error_debug (DebugDialog* self, GError* _error_, const char* debug);
PlayerWindow* player_window_new (void);
PlayerWindow* player_window_construct (GType object_type);
static GObject * player_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void player_window_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);




GType play_list_col_get_type (void) {
	static GType play_list_col_type_id = 0;
	if (G_UNLIKELY (play_list_col_type_id == 0)) {
		static const GEnumValue values[] = {{PLAY_LIST_COL_ICON, "PLAY_LIST_COL_ICON", "icon"}, {PLAY_LIST_COL_NAME, "PLAY_LIST_COL_NAME", "name"}, {PLAY_LIST_COL_FULLNAME, "PLAY_LIST_COL_FULLNAME", "fullname"}, {0, NULL, NULL}};
		play_list_col_type_id = g_enum_register_static ("PlayListCol", values);
	}
	return play_list_col_type_id;
}



GType player_tab_get_type (void) {
	static GType player_tab_type_id = 0;
	if (G_UNLIKELY (player_tab_type_id == 0)) {
		static const GEnumValue values[] = {{PLAYER_TAB_LIST, "PLAYER_TAB_LIST", "list"}, {PLAYER_TAB_VIDEO, "PLAYER_TAB_VIDEO", "video"}, {0, NULL, NULL}};
		player_tab_type_id = g_enum_register_static ("PlayerTab", values);
	}
	return player_tab_type_id;
}


static void _player_window_on_playlist_control_eos_play_list_control_eos (PlayListControl* _sender, gpointer self) {
	player_window_on_playlist_control_eos (self);
}


static void _player_window_on_playlist_control_error_play_list_control_error (PlayListControl* _sender, GError* e, const char* debug, gpointer self) {
	player_window_on_playlist_control_error (self, e, debug);
}


static void _player_window_on_playlist_control_playing_play_list_control_playing (PlayListControl* _sender, GtkTreeIter* iter, gpointer self) {
	player_window_on_playlist_control_playing (self, iter);
}


static void _player_window_on_playlist_control_paused_play_list_control_paused (PlayListControl* _sender, GtkTreeIter* iter, gpointer self) {
	player_window_on_playlist_control_paused (self, iter);
}


static void _player_window_on_playlist_control_stopped_play_list_control_stopped (PlayListControl* _sender, GtkTreeIter* iter, gpointer self) {
	player_window_on_playlist_control_stopped (self, iter);
}


static void _player_window_on_playlist_control_moved_play_list_control_moved (PlayListControl* _sender, GtkTreeIter* iter, gpointer self) {
	player_window_on_playlist_control_moved (self, iter);
}


void player_window_setup_elements (PlayerWindow* self) {
	PlayListControl* _tmp0_;
	g_return_if_fail (self != NULL);
	self->playlist_control = (_tmp0_ = play_list_control_new (self->playlist_store), _g_object_unref0 (self->playlist_control), _tmp0_);
	g_signal_connect_object (self->playlist_control, "eos", (GCallback) _player_window_on_playlist_control_eos_play_list_control_eos, self, 0);
	g_signal_connect_object (self->playlist_control, "error", (GCallback) _player_window_on_playlist_control_error_play_list_control_error, self, 0);
	g_signal_connect_object (self->playlist_control, "playing", (GCallback) _player_window_on_playlist_control_playing_play_list_control_playing, self, 0);
	g_signal_connect_object (self->playlist_control, "paused", (GCallback) _player_window_on_playlist_control_paused_play_list_control_paused, self, 0);
	g_signal_connect_object (self->playlist_control, "stopped", (GCallback) _player_window_on_playlist_control_stopped_play_list_control_stopped, self, 0);
	g_signal_connect_object (self->playlist_control, "moved", (GCallback) _player_window_on_playlist_control_moved_play_list_control_moved, self, 0);
}


static gboolean _player_window_on_delete_gtk_widget_delete_event (PlayerWindow* _sender, GdkEvent* event, gpointer self) {
	return player_window_on_delete (self);
}


static gboolean _lambda5_ (gint page, PlayerWindow* self) {
	gboolean result;
	g_print ("page %d\n", page);
}


static gboolean __lambda5__gtk_notebook_change_current_page (GtkNotebook* _sender, gint offset, gpointer self) {
	return _lambda5_ (offset, self);
}


static gboolean _player_window_on_seeking_scale_pressed_gtk_widget_button_press_event (GtkScale* _sender, GdkEventButton* event, gpointer self) {
	return player_window_on_seeking_scale_pressed (self);
}


static gboolean _player_window_on_seeking_scale_released_gtk_widget_button_release_event (GtkScale* _sender, GdkEventButton* event, gpointer self) {
	return player_window_on_seeking_scale_released (self);
}


static char* _player_window_on_scale_format_value_gtk_scale_format_value (GtkScale* _sender, double value, gpointer self) {
	return player_window_on_scale_format_value (self, value);
}


void player_window_setup_widgets (PlayerWindow* self) {
	GtkVBox* main_box;
	GtkBox* _tmp0_;
	GtkNotebook* _tmp1_;
	GtkLabel* _tmp3_;
	GtkBox* _tmp2_;
	GtkLabel* _tmp5_;
	GtkBox* _tmp4_;
	GtkAdjustment* _tmp6_;
	GtkScale* _tmp7_;
	g_return_if_fail (self != NULL);
	gtk_window_set_title ((GtkWindow*) self, TITLE);
	gtk_window_set_default_size ((GtkWindow*) self, DEFAULT_WIDTH, DEFAULT_HEIGHT);
	g_signal_connect_object ((GtkWidget*) self, "delete-event", (GCallback) _player_window_on_delete_gtk_widget_delete_event, self, 0);
	main_box = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) main_box);
	self->controls_box = (_tmp0_ = (GtkBox*) player_window_new_buttons_box (self), _g_object_unref0 (self->controls_box), _tmp0_);
	gtk_box_pack_start ((GtkBox*) main_box, (GtkWidget*) self->controls_box, FALSE, FALSE, (guint) 0);
	self->notebook = (_tmp1_ = g_object_ref_sink ((GtkNotebook*) gtk_notebook_new ()), _g_object_unref0 (self->notebook), _tmp1_);
	gtk_box_pack_start ((GtkBox*) main_box, (GtkWidget*) self->notebook, TRUE, TRUE, (guint) 0);
	gtk_notebook_set_show_tabs (self->notebook, FALSE);
	gtk_notebook_append_page (self->notebook, (GtkWidget*) (_tmp2_ = player_window_new_playlist_box (self)), (GtkWidget*) (_tmp3_ = g_object_ref_sink ((GtkLabel*) gtk_label_new ("List"))));
	_g_object_unref0 (_tmp3_);
	_g_object_unref0 (_tmp2_);
	gtk_notebook_append_page (self->notebook, (GtkWidget*) (_tmp4_ = player_window_new_video_box (self)), (GtkWidget*) (_tmp5_ = g_object_ref_sink ((GtkLabel*) gtk_label_new ("Video"))));
	_g_object_unref0 (_tmp5_);
	_g_object_unref0 (_tmp4_);
	g_signal_connect_object (self->notebook, "change-current-page", (GCallback) __lambda5__gtk_notebook_change_current_page, self, 0);
	gtk_widget_show ((GtkWidget*) self->notebook);
	self->seeking_adjustment = (_tmp6_ = g_object_ref_sink ((GtkAdjustment*) gtk_adjustment_new ((double) 0, (double) 0, (double) 100, 0.1, (double) 1, (double) 1)), _g_object_unref0 (self->seeking_adjustment), _tmp6_);
	self->seeking_scale = (_tmp7_ = (GtkScale*) g_object_ref_sink ((GtkHScale*) gtk_hscale_new (self->seeking_adjustment)), _g_object_unref0 (self->seeking_scale), _tmp7_);
	gtk_box_pack_start ((GtkBox*) main_box, (GtkWidget*) self->seeking_scale, FALSE, FALSE, (guint) 0);
	g_signal_connect_object ((GtkWidget*) self->seeking_scale, "button-press-event", (GCallback) _player_window_on_seeking_scale_pressed_gtk_widget_button_press_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self->seeking_scale, "button-release-event", (GCallback) _player_window_on_seeking_scale_released_gtk_widget_button_release_event, self, 0);
	g_signal_connect_object (self->seeking_scale, "format-value", (GCallback) _player_window_on_scale_format_value_gtk_scale_format_value, self, 0);
	gtk_widget_show ((GtkWidget*) main_box);
	gtk_widget_realize ((GtkWidget*) self->video_area);
	_g_object_unref0 (main_box);
}


gboolean player_window_is_playing (PlayerWindow* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = play_list_control_get_state (self->playlist_control) == GST_STATE_PLAYING;
	return result;
}


void player_window_on_play (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	play_list_control_play (self->playlist_control);
}


void player_window_on_pause (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	play_list_control_pause (self->playlist_control);
}


void player_window_on_stop (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	play_list_control_stop (self->playlist_control);
}


void player_window_on_next (PlayerWindow* self) {
	gboolean was_playing;
	g_return_if_fail (self != NULL);
	was_playing = player_window_is_playing (self);
	if (play_list_control_next (self->playlist_control)) {
		if (was_playing) {
			player_window_on_play (self);
		}
	} else {
		GtkTreeIter iter = {0};
		if (gtk_tree_model_get_iter_first ((GtkTreeModel*) self->playlist_store, &iter)) {
			gtk_tree_selection_select_iter (self->playlist_selection, &iter);
		}
	}
}


void player_window_on_prev (PlayerWindow* self) {
	gboolean was_playing;
	g_return_if_fail (self != NULL);
	was_playing = player_window_is_playing (self);
	if (play_list_control_prev (self->playlist_control)) {
		if (was_playing) {
			player_window_on_play (self);
		}
	}
}


static gboolean _player_window_on_delete_gsource_func (gpointer self) {
	return player_window_on_delete (self);
}


void player_window_on_quit (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, _player_window_on_delete_gsource_func, g_object_ref (self), g_object_unref);
}


gboolean player_window_on_delete (PlayerWindow* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	gtk_main_quit ();
	result = TRUE;
	return result;
}


static void _player_window_on_play_pause_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_play_pause (self);
}


static void _player_window_on_stop_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_stop (self);
}


static void _player_window_on_prev_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_prev (self);
}


static void _player_window_on_next_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_next (self);
}


static void _player_window_on_add_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_add (self);
}


static void _player_window_on_remove_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_remove (self);
}


static void _player_window_on_quit_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_quit (self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


GtkButtonBox* player_window_new_buttons_box (PlayerWindow* self) {
	GtkButtonBox* result;
	GtkHButtonBox* buttons_box;
	GtkButton* prev_button;
	GtkButton* play_pause_button;
	GtkButton* stop_button;
	GtkButton* _tmp0_;
	GtkButton* _tmp1_;
	GtkButton* remove_button;
	GtkButton* quit_button;
	GtkButton** _tmp3_;
	gint buttons_size;
	gint buttons_length1;
	GtkButton** _tmp2_ = NULL;
	GtkButton** buttons;
	gint i;
	GtkImage* _tmp5_;
	GtkWidget* _tmp4_;
	GtkImage* _tmp7_;
	GtkWidget* _tmp6_;
	GtkVolumeButton* _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	buttons_box = g_object_ref_sink ((GtkHButtonBox*) gtk_hbutton_box_new ());
	gtk_button_box_set_layout ((GtkButtonBox*) buttons_box, GTK_BUTTONBOX_START);
	gtk_box_set_spacing ((GtkBox*) buttons_box, 5);
	prev_button = new_button_with_stock_image (GTK_STOCK_MEDIA_PREVIOUS);
	play_pause_button = new_button_with_stock_image (GTK_STOCK_MEDIA_PLAY);
	stop_button = new_button_with_stock_image (GTK_STOCK_MEDIA_STOP);
	self->next_button = (_tmp0_ = new_button_with_stock_image (GTK_STOCK_MEDIA_NEXT), _g_object_unref0 (self->next_button), _tmp0_);
	self->add_button = (_tmp1_ = new_button_with_stock_image (GTK_STOCK_ADD), _g_object_unref0 (self->add_button), _tmp1_);
	remove_button = new_button_with_stock_image (GTK_STOCK_REMOVE);
	quit_button = new_button_with_stock_image (GTK_STOCK_QUIT);
	g_signal_connect_object (play_pause_button, "clicked", (GCallback) _player_window_on_play_pause_gtk_button_clicked, self, 0);
	g_signal_connect_object (stop_button, "clicked", (GCallback) _player_window_on_stop_gtk_button_clicked, self, 0);
	g_signal_connect_object (prev_button, "clicked", (GCallback) _player_window_on_prev_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->next_button, "clicked", (GCallback) _player_window_on_next_gtk_button_clicked, self, 0);
	g_signal_connect_object (self->add_button, "clicked", (GCallback) _player_window_on_add_gtk_button_clicked, self, 0);
	g_signal_connect_object (remove_button, "clicked", (GCallback) _player_window_on_remove_gtk_button_clicked, self, 0);
	g_signal_connect_object (quit_button, "clicked", (GCallback) _player_window_on_quit_gtk_button_clicked, self, 0);
	buttons = (_tmp3_ = (_tmp2_ = g_new0 (GtkButton*, 7 + 1), _tmp2_[0] = _g_object_ref0 (prev_button), _tmp2_[1] = _g_object_ref0 (play_pause_button), _tmp2_[2] = _g_object_ref0 (stop_button), _tmp2_[3] = _g_object_ref0 (self->next_button), _tmp2_[4] = _g_object_ref0 (self->add_button), _tmp2_[5] = _g_object_ref0 (remove_button), _tmp2_[6] = _g_object_ref0 (quit_button), _tmp2_), buttons_length1 = 7, buttons_size = buttons_length1, _tmp3_);
	i = 0;
	{
		GtkButton** button_collection;
		int button_collection_length1;
		int button_it;
		button_collection = buttons;
		button_collection_length1 = buttons_length1;
		for (button_it = 0; button_it < buttons_length1; button_it = button_it + 1) {
			GtkButton* button;
			button = _g_object_ref0 (button_collection[button_it]);
			{
				gtk_container_add ((GtkContainer*) buttons_box, (GtkWidget*) button);
				if (i >= 4) {
					gtk_button_box_set_child_secondary ((GtkButtonBox*) buttons_box, (GtkWidget*) button, TRUE);
				}
				i++;
				_g_object_unref0 (button);
			}
		}
	}
	self->play_pause_image = (_tmp5_ = _g_object_ref0 ((_tmp4_ = ((GtkBin*) play_pause_button)->child, GTK_IS_IMAGE (_tmp4_) ? ((GtkImage*) _tmp4_) : NULL)), _g_object_unref0 (self->play_pause_image), _tmp5_);
	self->remove_close_image = (_tmp7_ = _g_object_ref0 ((_tmp6_ = ((GtkBin*) remove_button)->child, GTK_IS_IMAGE (_tmp6_) ? ((GtkImage*) _tmp6_) : NULL)), _g_object_unref0 (self->remove_close_image), _tmp7_);
	self->volume_button = (_tmp8_ = player_window_new_volume_button_with_mute (self), _g_object_unref0 (self->volume_button), _tmp8_);
	gtk_container_add ((GtkContainer*) buttons_box, (GtkWidget*) self->volume_button);
	gtk_widget_show_all ((GtkWidget*) buttons_box);
	result = (GtkButtonBox*) buttons_box;
	_g_object_unref0 (prev_button);
	_g_object_unref0 (play_pause_button);
	_g_object_unref0 (stop_button);
	_g_object_unref0 (remove_button);
	_g_object_unref0 (quit_button);
	buttons = (_vala_array_free (buttons, buttons_length1, (GDestroyNotify) g_object_unref), NULL);
	return result;
}


void player_window_on_mute_clicked (PlayerWindow* self) {
	GtkAdjustment* volume;
	g_return_if_fail (self != NULL);
	volume = _g_object_ref0 (gtk_scale_button_get_adjustment ((GtkScaleButton*) self->volume_button));
	self->previous_volume = gtk_adjustment_get_value (volume);
	gtk_adjustment_set_value (volume, (double) 0);
	self->is_muted = TRUE;
	gtk_widget_hide (gtk_scale_button_get_popup ((GtkScaleButton*) self->volume_button));
	_g_object_unref0 (volume);
}


gboolean player_window_on_volume_button_pressed (PlayerWindow* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->is_muted) {
		GtkAdjustment* volume;
		volume = _g_object_ref0 (gtk_scale_button_get_adjustment ((GtkScaleButton*) self->volume_button));
		gtk_adjustment_set_value (volume, self->previous_volume);
		self->is_muted = FALSE;
		result = TRUE;
		_g_object_unref0 (volume);
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean _player_window_on_volume_button_pressed_gtk_widget_button_press_event (GtkVolumeButton* _sender, GdkEventButton* event, gpointer self) {
	return player_window_on_volume_button_pressed (self);
}


static void _player_window_on_mute_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	player_window_on_mute_clicked (self);
}


static void _lambda3_ (GtkAdjustment* volume, PlayerWindow* self) {
	g_return_if_fail (volume != NULL);
	play_list_control_set_volume (self->playlist_control, gtk_adjustment_get_value (volume));
}


static void __lambda3__gtk_adjustment_value_changed (GtkAdjustment* _sender, gpointer self) {
	_lambda3_ (_sender, self);
}


GtkVolumeButton* player_window_new_volume_button_with_mute (PlayerWindow* self) {
	GtkVolumeButton* result;
	GtkVolumeButton* volume_button;
	GtkWidget* _tmp0_;
	GtkWindow* popup_window;
	GtkWidget* _tmp1_;
	GtkFrame* popup_frame;
	GtkWidget* _tmp2_;
	GtkBox* popup_box;
	GtkButton* mute_button;
	char* _tmp5_;
	gint _tmp4__length1;
	char** _tmp4_;
	char** _tmp3_ = NULL;
	GtkImage* _tmp6_;
	GtkAdjustment* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	volume_button = g_object_ref_sink ((GtkVolumeButton*) gtk_volume_button_new ());
	g_object_set ((GtkScaleButton*) volume_button, "size", ICON_SIZE, NULL);
	g_signal_connect_object ((GtkWidget*) volume_button, "button-press-event", (GCallback) _player_window_on_volume_button_pressed_gtk_widget_button_press_event, self, 0);
	popup_window = _g_object_ref0 ((_tmp0_ = gtk_scale_button_get_popup ((GtkScaleButton*) volume_button), GTK_IS_WINDOW (_tmp0_) ? ((GtkWindow*) _tmp0_) : NULL));
	gtk_widget_set_size_request ((GtkWidget*) popup_window, -1, 240);
	popup_frame = _g_object_ref0 ((_tmp1_ = gtk_bin_get_child ((GtkBin*) popup_window), GTK_IS_FRAME (_tmp1_) ? ((GtkFrame*) _tmp1_) : NULL));
	popup_box = _g_object_ref0 ((_tmp2_ = gtk_bin_get_child ((GtkBin*) popup_frame), GTK_IS_BOX (_tmp2_) ? ((GtkBox*) _tmp2_) : NULL));
	gtk_box_set_spacing (popup_box, 24);
	gtk_container_remove ((GtkContainer*) popup_box, gtk_scale_button_get_plus_button ((GtkScaleButton*) volume_button));
	gtk_container_remove ((GtkContainer*) popup_box, gtk_scale_button_get_minus_button ((GtkScaleButton*) volume_button));
	mute_button = g_object_ref_sink ((GtkButton*) gtk_button_new ());
	gtk_box_pack_end (popup_box, (GtkWidget*) mute_button, FALSE, FALSE, (guint) 0);
	self->muted_icon_name = (_tmp5_ = g_strdup ((_tmp4_ = (g_object_get ((GtkScaleButton*) volume_button, "icons", &_tmp3_, NULL), _tmp3_), _tmp4__length1 = -1, _tmp4_)[0]), _g_free0 (self->muted_icon_name), _tmp5_);
	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
	self->mute_image = (_tmp6_ = g_object_ref_sink ((GtkImage*) gtk_image_new_from_icon_name (self->muted_icon_name, ICON_SIZE)), _g_object_unref0 (self->mute_image), _tmp6_);
	gtk_container_add ((GtkContainer*) mute_button, (GtkWidget*) self->mute_image);
	g_signal_connect_object (mute_button, "clicked", (GCallback) _player_window_on_mute_clicked_gtk_button_clicked, self, 0);
	gtk_widget_realize ((GtkWidget*) mute_button);
	self->volume_adjustment = (_tmp7_ = g_object_ref_sink ((GtkAdjustment*) gtk_adjustment_new ((double) 0, (double) 0, 1.0, 0.1, 0.1, (double) 0)), _g_object_unref0 (self->volume_adjustment), _tmp7_);
	gtk_scale_button_set_adjustment ((GtkScaleButton*) volume_button, self->volume_adjustment);
	g_signal_connect_object (self->volume_adjustment, "value-changed", (GCallback) __lambda3__gtk_adjustment_value_changed, self, 0);
	gtk_adjustment_set_value (self->volume_adjustment, play_list_control_get_volume (self->playlist_control));
	result = volume_button;
	_g_object_unref0 (popup_window);
	_g_object_unref0 (popup_frame);
	_g_object_unref0 (popup_box);
	_g_object_unref0 (mute_button);
	return result;
}


GtkBox* player_window_new_playlist_box (PlayerWindow* self) {
	GtkBox* result;
	GtkVBox* box;
	GtkScrolledWindow* scrolled_window;
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	box = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 6));
	scrolled_window = g_object_ref_sink ((GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL));
	gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) scrolled_window, TRUE, TRUE, (guint) 0);
	gtk_scrolled_window_set_policy (scrolled_window, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	self->playlist_view = (_tmp0_ = player_window_new_playlist_view (self), _g_object_unref0 (self->playlist_view), _tmp0_);
	gtk_container_add ((GtkContainer*) scrolled_window, (GtkWidget*) self->playlist_view);
	gtk_tree_view_set_model (self->playlist_view, (GtkTreeModel*) self->playlist_store);
	self->playlist_selection = (_tmp1_ = _g_object_ref0 (gtk_tree_view_get_selection (self->playlist_view)), _g_object_unref0 (self->playlist_selection), _tmp1_);
	gtk_tree_selection_set_mode (self->playlist_selection, GTK_SELECTION_BROWSE);
	gtk_widget_show_all ((GtkWidget*) box);
	result = (GtkBox*) box;
	_g_object_unref0 (scrolled_window);
	return result;
}


static void _player_window_on_video_area_activated_video_area_activated (VideoArea* _sender, gpointer self) {
	player_window_on_video_area_activated (self);
}


static void _lambda4_ (PlayerWindow* self) {
	gtk_notebook_set_current_page (self->notebook, (gint) PLAYER_TAB_VIDEO);
}


static void __lambda4__video_area_prepared (VideoArea* _sender, gpointer self) {
	_lambda4_ (self);
}


GtkBox* player_window_new_video_box (PlayerWindow* self) {
	GtkBox* result;
	GtkVBox* box;
	VideoArea* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	box = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 6));
	self->video_area = (_tmp0_ = g_object_ref_sink (video_area_new ()), _g_object_unref0 (self->video_area), _tmp0_);
	gtk_box_pack_start ((GtkBox*) box, (GtkWidget*) self->video_area, TRUE, TRUE, (guint) 0);
	g_signal_connect_object (self->video_area, "activated", (GCallback) _player_window_on_video_area_activated_video_area_activated, self, 0);
	g_signal_connect_object (self->video_area, "prepared", (GCallback) __lambda4__video_area_prepared, self, 0);
	video_area_set_control (self->video_area, (Control*) self->playlist_control);
	gtk_widget_show_all ((GtkWidget*) box);
	result = (GtkBox*) box;
	return result;
}


static void _player_window_on_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self) {
	player_window_on_row_activated (self, path);
}


GtkTreeView* player_window_new_playlist_view (PlayerWindow* self) {
	GtkTreeView* result;
	GtkTreeView* view;
	GtkCellRendererPixbuf* _tmp0_;
	GtkCellRendererText* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	view = g_object_ref_sink ((GtkTreeView*) gtk_tree_view_new ());
	gtk_tree_view_set_headers_visible (view, FALSE);
	g_signal_connect_object (view, "row-activated", (GCallback) _player_window_on_row_activated_gtk_tree_view_row_activated, self, 0);
	gtk_tree_view_insert_column_with_attributes (view, -1, "Icon", (GtkCellRenderer*) (_tmp0_ = g_object_ref_sink ((GtkCellRendererPixbuf*) gtk_cell_renderer_pixbuf_new ())), "stock-id", PLAY_LIST_COL_ICON, NULL, NULL);
	_g_object_unref0 (_tmp0_);
	gtk_tree_view_insert_column_with_attributes (view, -1, "Song", (GtkCellRenderer*) (_tmp1_ = g_object_ref_sink ((GtkCellRendererText*) gtk_cell_renderer_text_new ())), "markup", PLAY_LIST_COL_NAME, NULL, NULL);
	_g_object_unref0 (_tmp1_);
	gtk_widget_show_all ((GtkWidget*) view);
	result = view;
	return result;
}


GtkListStore* player_window_new_playlist_store (PlayerWindow* self) {
	GtkListStore* result;
	GType s;
	GtkListStore* model;
	g_return_val_if_fail (self != NULL, NULL);
	s = G_TYPE_STRING;
	model = gtk_list_store_new (3, s, s, s, NULL);
	result = model;
	return result;
}


gboolean player_window_get_and_select_iter (PlayerWindow* self, GtkTreeIter* iter) {
	gboolean result;
	GtkTreePath* path;
	g_return_val_if_fail (self != NULL, FALSE);
	if (!gtk_tree_selection_get_selected (self->playlist_selection, NULL, iter)) {
		if (!play_list_control_get_iter (self->playlist_control, iter)) {
			if (!gtk_tree_model_get_iter_first ((GtkTreeModel*) self->playlist_store, iter)) {
				result = FALSE;
				return result;
			}
		}
	}
	path = gtk_tree_model_get_path ((GtkTreeModel*) self->playlist_store, iter);
	play_list_control_move_to (self->playlist_control, path);
	result = TRUE;
	_gtk_tree_path_free0 (path);
	return result;
}


void player_window_on_play_pause (PlayerWindow* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	switch (play_list_control_get_state (self->playlist_control)) {
		case GST_STATE_PLAYING:
		{
			{
				player_window_on_pause (self);
			}
			break;
		}
		case GST_STATE_PAUSED:
		{
			{
				player_window_on_play (self);
			}
			break;
		}
		case GST_STATE_NULL:
		{
			{
				GtkTreePath* row;
				if (!player_window_get_and_select_iter (self, &iter)) {
					return;
				}
				row = gtk_tree_model_get_path ((GtkTreeModel*) self->playlist_store, &iter);
				play_list_control_move_to (self->playlist_control, row);
				gtk_notebook_set_current_page (self->notebook, (gint) PLAYER_TAB_LIST);
				player_window_on_play (self);
				_gtk_tree_path_free0 (row);
			}
			break;
		}
	}
}


void player_window_on_playlist_control_playing (PlayerWindow* self, GtkTreeIter* iter) {
	char* name;
	g_return_if_fail (self != NULL);
	name = NULL;
	gtk_tree_model_get ((GtkTreeModel*) self->playlist_store, iter, PLAY_LIST_COL_NAME, &name, -1, -1);
	gtk_window_set_title ((GtkWindow*) self, name);
	gtk_image_set_from_stock (self->play_pause_image, GTK_STOCK_MEDIA_PAUSE, ICON_SIZE);
	player_window_add_update_scale_timeout (self);
	gtk_widget_show ((GtkWidget*) self->seeking_scale);
	_g_free0 (name);
}


void player_window_on_playlist_control_paused (PlayerWindow* self, GtkTreeIter* iter) {
	g_return_if_fail (self != NULL);
	gtk_image_set_from_stock (self->play_pause_image, GTK_STOCK_MEDIA_PLAY, ICON_SIZE);
	player_window_remove_update_scale_timeout (self);
}


void player_window_on_playlist_control_stopped (PlayerWindow* self, GtkTreeIter* iter) {
	gint page;
	g_return_if_fail (self != NULL);
	gtk_window_set_title ((GtkWindow*) self, TITLE);
	page = gtk_notebook_get_current_page (self->notebook);
	if (page != PLAYER_TAB_LIST) {
		gtk_notebook_set_current_page (self->notebook, (gint) PLAYER_TAB_LIST);
	}
	gtk_image_set_from_stock (self->play_pause_image, GTK_STOCK_MEDIA_PLAY, ICON_SIZE);
	player_window_remove_update_scale_timeout (self);
	gtk_widget_hide ((GtkWidget*) self->seeking_scale);
}


void player_window_on_playlist_control_moved (PlayerWindow* self, GtkTreeIter* iter) {
	g_return_if_fail (self != NULL);
	gtk_tree_selection_select_iter (self->playlist_selection, iter);
}


void player_window_on_add (PlayerWindow* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	player_window_setup_chooser (self);
	gtk_widget_show_all ((GtkWidget*) self->chooser);
	gtk_dialog_run ((GtkDialog*) self->chooser);
	player_window_get_and_select_iter (self, &iter);
}


static void _player_window_on_chooser_response_gtk_dialog_response (GtkFileChooserDialog* _sender, gint response_id, gpointer self) {
	player_window_on_chooser_response (self, response_id);
}


void player_window_setup_chooser (PlayerWindow* self) {
	GtkFileChooserDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	if (self->chooser != NULL) {
		return;
	}
	self->chooser = (_tmp0_ = g_object_ref_sink ((GtkFileChooserDialog*) gtk_file_chooser_dialog_new ("Add files to playlist", (GtkWindow*) self, GTK_FILE_CHOOSER_ACTION_OPEN, GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE, GTK_STOCK_ADD, GTK_RESPONSE_OK, NULL, NULL)), _g_object_unref0 (self->chooser), _tmp0_);
	g_signal_connect_object ((GtkDialog*) self->chooser, "response", (GCallback) _player_window_on_chooser_response_gtk_dialog_response, self, 0);
}


void player_window_on_chooser_response (PlayerWindow* self, gint response) {
	g_return_if_fail (self != NULL);
	switch (response) {
		case GTK_RESPONSE_CLOSE:
		{
			{
				gtk_widget_hide ((GtkWidget*) self->chooser);
			}
			break;
		}
		case GTK_RESPONSE_OK:
		{
			{
				char* _tmp0_;
				play_list_control_add_file (self->playlist_control, _tmp0_ = gtk_file_chooser_get_filename ((GtkFileChooser*) self->chooser));
				_g_free0 (_tmp0_);
			}
			break;
		}
	}
}


void player_window_on_remove (PlayerWindow* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	player_window_on_remove_files (self);
	player_window_get_and_select_iter (self, &iter);
}


static void _g_list_free_gtk_tree_path_free (GList* self) {
	g_list_foreach (self, (GFunc) gtk_tree_path_free, NULL);
	g_list_free (self);
}


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


void player_window_on_remove_files (PlayerWindow* self) {
	GtkTreeIter iter = {0};
	g_return_if_fail (self != NULL);
	{
		GList* row_collection;
		GList* row_it;
		row_collection = gtk_tree_selection_get_selected_rows (self->playlist_selection, NULL);
		for (row_it = row_collection; row_it != NULL; row_it = row_it->next) {
			GtkTreePath* row;
			row = _gtk_tree_path_copy0 ((GtkTreePath*) row_it->data);
			{
				gtk_tree_model_get_iter ((GtkTreeModel*) self->playlist_store, &iter, row);
				gtk_list_store_remove (self->playlist_store, &iter);
				_gtk_tree_path_free0 (row);
			}
		}
		__g_list_free_gtk_tree_path_free0 (row_collection);
	}
}


void player_window_on_row_activated (PlayerWindow* self, GtkTreePath* row) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (row != NULL);
	player_window_on_stop (self);
	if (play_list_control_move_to (self->playlist_control, row)) {
		player_window_on_play (self);
	}
}


gboolean player_window_on_seeking_scale_pressed (PlayerWindow* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	if (player_window_is_playing (self)) {
		player_window_on_pause (self);
		self->should_resume_playback = TRUE;
	} else {
		self->should_resume_playback = FALSE;
	}
	result = FALSE;
	return result;
}


gboolean player_window_on_seeking_scale_released (PlayerWindow* self) {
	gboolean result;
	gint64 real_value = 0LL;
	g_return_val_if_fail (self != NULL, FALSE);
	real_value = (gint64) ((gtk_range_get_value ((GtkRange*) self->seeking_scale) * self->stream_duration) / 100);
	play_list_control_seek (self->playlist_control, real_value);
	if (self->should_resume_playback) {
		player_window_on_play (self);
	}
	result = FALSE;
	return result;
}


char* player_window_on_scale_format_value (PlayerWindow* self, double scale_value) {
	char* result;
	double real_value = 0.0;
	double real_duration = 0.0;
	gint sec0;
	gint sec1;
	g_return_val_if_fail (self != NULL, NULL);
	if (self->stream_duration == (-1)) {
		real_value = (double) 0;
		real_duration = (double) 0;
	} else {
		real_value = (scale_value * self->stream_duration) / 100.0;
		real_duration = (double) self->stream_duration;
	}
	sec0 = (gint) (real_value / GST_SECOND);
	sec1 = (gint) (real_duration / GST_SECOND);
	result = g_strdup_printf ("%02d:%02d/%02d:%02d", sec0 / 60, sec0 % 60, sec1 / 60, sec1 % 60);
	return result;
}


static gboolean _player_window_update_scale_timeout_gsource_func (gpointer self) {
	return player_window_update_scale_timeout (self);
}


void player_window_add_update_scale_timeout (PlayerWindow* self) {
	guint timeout_id;
	g_return_if_fail (self != NULL);
	if (self->update_seeking_scale_id != 0) {
		return;
	}
	timeout_id = g_timeout_add_full (G_PRIORITY_DEFAULT, UPDATE_INTERVAL, _player_window_update_scale_timeout_gsource_func, g_object_ref (self), g_object_unref);
	self->update_seeking_scale_id = timeout_id;
}


void player_window_remove_update_scale_timeout (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	if (self->update_seeking_scale_id == 0) {
		return;
	}
	g_source_remove (self->update_seeking_scale_id);
	self->update_seeking_scale_id = (guint) 0;
}


gboolean player_window_update_scale_timeout (PlayerWindow* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	self->stream_position = play_list_control_get_position (self->playlist_control);
	self->stream_duration = play_list_control_get_duration (self->playlist_control);
	if (self->stream_position >= 0) {
		_tmp0_ = self->stream_duration > 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		double stream_value;
		stream_value = (self->stream_position * 100.0) / self->stream_duration;
		gtk_adjustment_set_value (self->seeking_adjustment, stream_value);
	}
	result = TRUE;
	return result;
}


void player_window_on_video_area_activated (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	if (self->is_fullscreen) {
		gtk_widget_show ((GtkWidget*) self->controls_box);
		gtk_widget_show ((GtkWidget*) self->seeking_scale);
		gtk_window_unfullscreen ((GtkWindow*) self);
		gtk_window_activate_default ((GtkWindow*) self);
		self->is_fullscreen = FALSE;
	} else {
		gtk_widget_hide ((GtkWidget*) self->controls_box);
		gtk_widget_hide ((GtkWidget*) self->seeking_scale);
		gtk_window_fullscreen ((GtkWindow*) self);
		self->is_fullscreen = TRUE;
		gtk_widget_grab_focus ((GtkWidget*) self->controls_box);
	}
}


static void _player_window_on_debug_dialog_closed_debug_dialog_closed (DebugDialog* _sender, gpointer self) {
	player_window_on_debug_dialog_closed (self);
}


void player_window_setup_debug_dialog (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	if (self->debug_dialog == NULL) {
		DebugDialog* _tmp0_;
		gtk_widget_hide ((GtkWidget*) self->seeking_scale);
		gtk_widget_hide ((GtkWidget*) self->controls_box);
		self->debug_dialog = (_tmp0_ = g_object_ref_sink (debug_dialog_new ((GtkWindow*) self)), _g_object_unref0 (self->debug_dialog), _tmp0_);
		g_signal_connect_object (self->debug_dialog, "closed", (GCallback) _player_window_on_debug_dialog_closed_debug_dialog_closed, self, 0);
		gtk_widget_show_all ((GtkWidget*) self->debug_dialog);
	}
}


void player_window_on_debug_dialog_closed (PlayerWindow* self) {
	DebugDialog* _tmp0_;
	g_return_if_fail (self != NULL);
	gtk_widget_show ((GtkWidget*) self->controls_box);
	player_window_on_stop (self);
	self->debug_dialog = (_tmp0_ = NULL, _g_object_unref0 (self->debug_dialog), _tmp0_);
}


void player_window_on_playlist_control_eos (PlayerWindow* self) {
	g_return_if_fail (self != NULL);
	g_signal_emit_by_name (self->next_button, "activate");
}


void player_window_on_playlist_control_error (PlayerWindow* self, GError* _error_, const char* debug) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (debug != NULL);
	player_window_setup_debug_dialog (self);
	debug_dialog_add_error_debug (self->debug_dialog, _error_, debug);
}


PlayerWindow* player_window_construct (GType object_type) {
	PlayerWindow * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


PlayerWindow* player_window_new (void) {
	return player_window_construct (TYPE_PLAYER_WINDOW);
}


static GObject * player_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	PlayerWindow * self;
	parent_class = G_OBJECT_CLASS (player_window_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = PLAYER_WINDOW (obj);
	{
		GtkListStore* _tmp0_;
		self->playlist_store = (_tmp0_ = player_window_new_playlist_store (self), _g_object_unref0 (self->playlist_store), _tmp0_);
		player_window_setup_elements (self);
		player_window_setup_widgets (self);
	}
	return obj;
}


static void player_window_class_init (PlayerWindowClass * klass) {
	player_window_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = player_window_constructor;
	G_OBJECT_CLASS (klass)->finalize = player_window_finalize;
}


static void player_window_instance_init (PlayerWindow * self) {
}


static void player_window_finalize (GObject* obj) {
	PlayerWindow * self;
	self = PLAYER_WINDOW (obj);
	_g_object_unref0 (self->playlist_view);
	_g_object_unref0 (self->playlist_store);
	_g_object_unref0 (self->playlist_selection);
	_g_object_unref0 (self->playlist_control);
	_g_object_unref0 (self->controls_box);
	_g_object_unref0 (self->notebook);
	_g_object_unref0 (self->add_button);
	_g_object_unref0 (self->next_button);
	_g_object_unref0 (self->play_pause_image);
	_g_object_unref0 (self->remove_close_image);
	_g_object_unref0 (self->remove_image);
	_g_object_unref0 (self->video_area);
	_g_object_unref0 (self->seeking_scale);
	_g_object_unref0 (self->seeking_adjustment);
	_g_object_unref0 (self->volume_button);
	_g_object_unref0 (self->volume_adjustment);
	_g_object_unref0 (self->mute_image);
	_g_free0 (self->muted_icon_name);
	_g_object_unref0 (self->chooser);
	_g_object_unref0 (self->debug_dialog);
	G_OBJECT_CLASS (player_window_parent_class)->finalize (obj);
}


GType player_window_get_type (void) {
	static GType player_window_type_id = 0;
	if (player_window_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (PlayerWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlayerWindow), 0, (GInstanceInitFunc) player_window_instance_init, NULL };
		player_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "PlayerWindow", &g_define_type_info, 0);
	}
	return player_window_type_id;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}




