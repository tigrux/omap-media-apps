/* muxer-config.c generated by valac 0.10.0, the Vala compiler
 * generated from muxer-config.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>


#define OMAP_TYPE_MUXER_CONFIG_PARSER (omap_muxer_config_parser_get_type ())
#define OMAP_MUXER_CONFIG_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OMAP_TYPE_MUXER_CONFIG_PARSER, OmapMuxerConfigParser))
#define OMAP_MUXER_CONFIG_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OMAP_TYPE_MUXER_CONFIG_PARSER, OmapMuxerConfigParserClass))
#define OMAP_IS_MUXER_CONFIG_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OMAP_TYPE_MUXER_CONFIG_PARSER))
#define OMAP_IS_MUXER_CONFIG_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OMAP_TYPE_MUXER_CONFIG_PARSER))
#define OMAP_MUXER_CONFIG_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OMAP_TYPE_MUXER_CONFIG_PARSER, OmapMuxerConfigParserClass))

typedef struct _OmapMuxerConfigParser OmapMuxerConfigParser;
typedef struct _OmapMuxerConfigParserClass OmapMuxerConfigParserClass;
typedef struct _OmapMuxerConfigParserPrivate OmapMuxerConfigParserPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_markup_parse_context_free0(var) ((var == NULL) ? NULL : (var = (g_markup_parse_context_free (var), NULL)))
#define __g_list_free_g_free0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_free (var), NULL)))

struct _OmapMuxerConfigParser {
	GObject parent_instance;
	OmapMuxerConfigParserPrivate * priv;
	char* current_group;
	char* current_key;
	char* current_value;
	GMarkupParseContext* context;
	GKeyFile* config_key_file;
	gboolean has_preview;
	gboolean has_record;
};

struct _OmapMuxerConfigParserClass {
	GObjectClass parent_class;
};


static gpointer omap_muxer_config_parser_parent_class = NULL;

GType omap_muxer_config_parser_get_type (void) G_GNUC_CONST;
enum  {
	OMAP_MUXER_CONFIG_PARSER_DUMMY_PROPERTY
};
void omap_muxer_config_parser_start (OmapMuxerConfigParser* self, GMarkupParseContext* context, const char* name, char** attr_names, int attr_names_length1, char** attr_values, int attr_values_length1, GError** error);
static void _omap_muxer_config_parser_start_gmarkup_parser_start_element_func (GMarkupParseContext* context, const char* element_name, char** attribute_names, char** attribute_values, gpointer self, GError** error);
void omap_muxer_config_parser_end (OmapMuxerConfigParser* self, GMarkupParseContext* context, const char* name, GError** error);
static void _omap_muxer_config_parser_end_gmarkup_parser_end_element_func (GMarkupParseContext* context, const char* element_name, gpointer self, GError** error);
void omap_muxer_config_parser_text (OmapMuxerConfigParser* self, GMarkupParseContext* context, const char* text, gsize text_len, GError** error);
static void _omap_muxer_config_parser_text_gmarkup_parser_text_func (GMarkupParseContext* context, const char* text, gsize text_len, gpointer self, GError** error);
gboolean omap_muxer_config_parser_parse_data (OmapMuxerConfigParser* self, const char* data, gssize length, GKeyFile** key_file, GError** error);
gboolean omap_muxer_config_parser_parse_file (OmapMuxerConfigParser* self, const char* file, GKeyFile** key_file, GError** error);
gboolean omap_muxer_config_parser_normalize_value (OmapMuxerConfigParser* self);
static void _g_list_free_g_free (GList* self);
OmapMuxerConfigParser* omap_muxer_config_parser_new (void);
OmapMuxerConfigParser* omap_muxer_config_parser_construct (GType object_type);
static GObject * omap_muxer_config_parser_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void omap_muxer_config_parser_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);

const GMarkupParser OMAP_MUXER_CONFIG_PARSER_parser = {_omap_muxer_config_parser_start_gmarkup_parser_start_element_func, _omap_muxer_config_parser_end_gmarkup_parser_end_element_func, _omap_muxer_config_parser_text_gmarkup_parser_text_func, NULL, NULL};


static void _omap_muxer_config_parser_start_gmarkup_parser_start_element_func (GMarkupParseContext* context, const char* element_name, char** attribute_names, char** attribute_values, gpointer self, GError** error) {
	omap_muxer_config_parser_start (self, context, element_name, attribute_names, _vala_array_length (attribute_names), attribute_values, _vala_array_length (attribute_values), error);
}


static void _omap_muxer_config_parser_end_gmarkup_parser_end_element_func (GMarkupParseContext* context, const char* element_name, gpointer self, GError** error) {
	omap_muxer_config_parser_end (self, context, element_name, error);
}


static void _omap_muxer_config_parser_text_gmarkup_parser_text_func (GMarkupParseContext* context, const char* text, gsize text_len, gpointer self, GError** error) {
	omap_muxer_config_parser_text (self, context, text, text_len, error);
}


gboolean omap_muxer_config_parser_parse_data (OmapMuxerConfigParser* self, const char* data, gssize length, GKeyFile** key_file, GError** error) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (data != NULL, FALSE);
	g_return_val_if_fail (key_file != NULL, FALSE);
	self->config_key_file = *key_file;
	_tmp0_ = g_markup_parse_context_parse (self->context, data, length, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == G_MARKUP_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	result = _tmp0_;
	return result;
}


gboolean omap_muxer_config_parser_parse_file (OmapMuxerConfigParser* self, const char* file, GKeyFile** key_file, GError** error) {
	gboolean result = FALSE;
	char* content;
	gsize length = 0UL;
	char* _tmp0_ = NULL;
	gboolean _tmp1_;
	char* _tmp2_;
	gboolean _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	g_return_val_if_fail (key_file != NULL, FALSE);
	content = NULL;
	_tmp3_ = (_tmp1_ = g_file_get_contents (file, &_tmp0_, &length, &_inner_error_), content = (_tmp2_ = _tmp0_, _g_free0 (content), _tmp2_), _tmp1_);
	if (_inner_error_ != NULL) {
		if ((_inner_error_->domain == G_MARKUP_ERROR) || (_inner_error_->domain == G_FILE_ERROR)) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (content);
			return FALSE;
		} else {
			_g_free0 (content);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	if (_tmp3_) {
		gboolean _tmp4_;
		_tmp4_ = omap_muxer_config_parser_parse_data (self, content, (gssize) length, key_file, &_inner_error_);
		if (_inner_error_ != NULL) {
			if ((_inner_error_->domain == G_MARKUP_ERROR) || (_inner_error_->domain == G_FILE_ERROR)) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (content);
				return FALSE;
			} else {
				_g_free0 (content);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
		}
		result = _tmp4_;
		_g_free0 (content);
		return result;
	}
	result = FALSE;
	_g_free0 (content);
	return result;
}


void omap_muxer_config_parser_start (OmapMuxerConfigParser* self, GMarkupParseContext* context, const char* name, char** attr_names, int attr_names_length1, char** attr_values, int attr_values_length1, GError** error) {
	gint line_n = 0;
	gint char_n = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (name != NULL);
	g_markup_parse_context_get_position (context, &line_n, &char_n);
	if (_vala_strcmp0 (name, "pipeline") == 0) {
		char* _tmp0_;
		gint i;
		char* attr_name;
		self->current_key = (_tmp0_ = NULL, _g_free0 (self->current_key), _tmp0_);
		self->has_preview = FALSE;
		self->has_record = FALSE;
		i = 0;
		attr_name = NULL;
		while (TRUE) {
			char* _tmp1_;
			if (!((attr_name = (_tmp1_ = g_strdup (attr_names[i]), _g_free0 (attr_name), _tmp1_)) != NULL)) {
				break;
			}
			if (_vala_strcmp0 (attr_name, "name") == 0) {
				char* attr_value;
				attr_value = g_strdup (attr_values[i]);
				if (attr_value != NULL) {
					char* _tmp2_;
					self->current_group = (_tmp2_ = g_strdup (attr_values[i]), _g_free0 (self->current_group), _tmp2_);
				}
				_g_free0 (attr_value);
			} else {
				_inner_error_ = g_error_new (G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, "Error on line %d char %d: Element '%s' has unknown attribute '%s'", line_n, char_n, name, attr_name);
				{
					if (_inner_error_->domain == G_MARKUP_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (attr_name);
						return;
					} else {
						_g_free0 (attr_name);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
			i++;
		}
		if (self->current_group == NULL) {
			_inner_error_ = g_error_new (G_MARKUP_ERROR, G_MARKUP_ERROR_MISSING_ATTRIBUTE, "Error on line %d char %d: Element '%s' has no attribute 'name'", line_n, char_n, name);
			{
				if (_inner_error_->domain == G_MARKUP_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (attr_name);
					return;
				} else {
					_g_free0 (attr_name);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
		_g_free0 (attr_name);
	} else {
		gboolean _tmp3_ = FALSE;
		if (_vala_strcmp0 (name, "preview") == 0) {
			self->has_preview = TRUE;
		} else {
			if (_vala_strcmp0 (name, "record") == 0) {
				self->has_record = TRUE;
			}
		}
		if (self->has_preview) {
			_tmp3_ = TRUE;
		} else {
			_tmp3_ = self->has_record;
		}
		if (_tmp3_) {
			if (self->current_group != NULL) {
				char* _tmp4_;
				self->current_key = (_tmp4_ = g_strdup (name), _g_free0 (self->current_key), _tmp4_);
			} else {
				_inner_error_ = g_error_new (G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT, "Error on line %d char %d: Element '%s' was opened, but no outer elemen" \
"t 'pipeline' was found", line_n, char_n, name);
				{
					if (_inner_error_->domain == G_MARKUP_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
		} else {
			_inner_error_ = g_error_new (G_MARKUP_ERROR, G_MARKUP_ERROR_UNKNOWN_ELEMENT, "Error on line %d char %d: Element '%s' in unknown", line_n, char_n, name);
			{
				if (_inner_error_->domain == G_MARKUP_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


void omap_muxer_config_parser_end (OmapMuxerConfigParser* self, GMarkupParseContext* context, const char* name, GError** error) {
	gint line_n = 0;
	gint char_n = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (name != NULL);
	g_markup_parse_context_get_position (context, &line_n, &char_n);
	if (_vala_strcmp0 (name, "pipeline") == 0) {
		char* _tmp0_;
		char* missing_tag;
		self->current_group = (_tmp0_ = NULL, _g_free0 (self->current_group), _tmp0_);
		missing_tag = NULL;
		if (!self->has_preview) {
			char* _tmp1_;
			missing_tag = (_tmp1_ = g_strdup ("preview"), _g_free0 (missing_tag), _tmp1_);
		} else {
			if (!self->has_record) {
				char* _tmp2_;
				missing_tag = (_tmp2_ = g_strdup ("record"), _g_free0 (missing_tag), _tmp2_);
			} else {
				char* _tmp3_;
				missing_tag = (_tmp3_ = NULL, _g_free0 (missing_tag), _tmp3_);
			}
		}
		if (missing_tag != NULL) {
			_inner_error_ = g_error_new (G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT, "Error on line %d char %d: Element '%s' was closed, but no inner elemen" \
"t '%s' was found", line_n, char_n, name, missing_tag);
			{
				if (_inner_error_->domain == G_MARKUP_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (missing_tag);
					return;
				} else {
					_g_free0 (missing_tag);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
		_g_free0 (missing_tag);
	} else {
		gboolean _tmp4_ = FALSE;
		if (_vala_strcmp0 (name, "preview") == 0) {
			_tmp4_ = TRUE;
		} else {
			_tmp4_ = _vala_strcmp0 (name, "record") == 0;
		}
		if (_tmp4_) {
			if (omap_muxer_config_parser_normalize_value (self)) {
				char* _tmp5_;
				g_key_file_set_string (self->config_key_file, self->current_group, self->current_key, self->current_value);
				self->current_key = (_tmp5_ = NULL, _g_free0 (self->current_key), _tmp5_);
			} else {
				_inner_error_ = g_error_new (G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT, "Error on line %d char %d: Element '%s' has no text", line_n, char_n, name);
				{
					if (_inner_error_->domain == G_MARKUP_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
		}
	}
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


static void _g_list_free_g_free (GList* self) {
	g_list_foreach (self, (GFunc) g_free, NULL);
	g_list_free (self);
}


gboolean omap_muxer_config_parser_normalize_value (OmapMuxerConfigParser* self) {
	gboolean result = FALSE;
	GList* stripped_list;
	gint lines_length1;
	gint _lines_size_;
	char** lines;
	gint i = 0;
	char** _tmp0_;
	char** _tmp1_;
	char* line;
	gint _tmp3_;
	char** _tmp4_;
	char* _tmp6_;
	g_return_val_if_fail (self != NULL, FALSE);
	if (self->current_value == NULL) {
		result = FALSE;
		return result;
	}
	stripped_list = NULL;
	lines = (lines_length1 = 0, NULL);
	lines = (_tmp1_ = _tmp0_ = g_strsplit (self->current_value, "\n", 0), lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL), lines_length1 = _vala_array_length (_tmp0_), _lines_size_ = lines_length1, _tmp1_);
	i = 0;
	line = NULL;
	while (TRUE) {
		char* _tmp2_;
		if (!((line = (_tmp2_ = g_strdup (lines[i]), _g_free0 (line), _tmp2_)) != NULL)) {
			break;
		}
		if (string_get_length (line) > 0) {
			stripped_list = g_list_append (stripped_list, g_strdup (line));
		}
		i++;
	}
	lines = (_tmp4_ = g_new0 (char*, (_tmp3_ = g_list_length (stripped_list)) + 1), lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL), lines_length1 = _tmp3_, _lines_size_ = lines_length1, _tmp4_);
	i = 0;
	{
		GList* line_collection;
		GList* line_it;
		line_collection = stripped_list;
		for (line_it = line_collection; line_it != NULL; line_it = line_it->next) {
			char* line;
			line = g_strdup ((const char*) line_it->data);
			{
				char* _tmp5_;
				lines[i] = (_tmp5_ = g_strdup (line), _g_free0 (lines[i]), _tmp5_);
				i++;
				_g_free0 (line);
			}
		}
	}
	self->current_value = (_tmp6_ = g_strjoinv (" ", lines), _g_free0 (self->current_value), _tmp6_);
	if (string_get_length (self->current_value) == 0) {
		result = FALSE;
		_g_free0 (line);
		lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
		__g_list_free_g_free0 (stripped_list);
		return result;
	}
	result = TRUE;
	_g_free0 (line);
	lines = (_vala_array_free (lines, lines_length1, (GDestroyNotify) g_free), NULL);
	__g_list_free_g_free0 (stripped_list);
	return result;
}


void omap_muxer_config_parser_text (OmapMuxerConfigParser* self, GMarkupParseContext* context, const char* text, gsize text_len, GError** error) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	g_return_if_fail (text != NULL);
	if (self->current_group != NULL) {
		_tmp0_ = self->current_key != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		char* _tmp1_;
		self->current_value = (_tmp1_ = g_strdup (text), _g_free0 (self->current_value), _tmp1_);
	}
}


OmapMuxerConfigParser* omap_muxer_config_parser_construct (GType object_type) {
	OmapMuxerConfigParser * self;
	self = (OmapMuxerConfigParser*) g_object_new (object_type, NULL);
	return self;
}


OmapMuxerConfigParser* omap_muxer_config_parser_new (void) {
	return omap_muxer_config_parser_construct (OMAP_TYPE_MUXER_CONFIG_PARSER);
}


static GObject * omap_muxer_config_parser_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	OmapMuxerConfigParser * self;
	parent_class = G_OBJECT_CLASS (omap_muxer_config_parser_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = OMAP_MUXER_CONFIG_PARSER (obj);
	{
		GMarkupParseContext* _tmp0_;
		self->context = (_tmp0_ = g_markup_parse_context_new (&OMAP_MUXER_CONFIG_PARSER_parser, 0, self, NULL), _g_markup_parse_context_free0 (self->context), _tmp0_);
	}
	return obj;
}


static void omap_muxer_config_parser_class_init (OmapMuxerConfigParserClass * klass) {
	omap_muxer_config_parser_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = omap_muxer_config_parser_constructor;
	G_OBJECT_CLASS (klass)->finalize = omap_muxer_config_parser_finalize;
}


static void omap_muxer_config_parser_instance_init (OmapMuxerConfigParser * self) {
}


static void omap_muxer_config_parser_finalize (GObject* obj) {
	OmapMuxerConfigParser * self;
	self = OMAP_MUXER_CONFIG_PARSER (obj);
	_g_free0 (self->current_group);
	_g_free0 (self->current_key);
	_g_free0 (self->current_value);
	_g_markup_parse_context_free0 (self->context);
	G_OBJECT_CLASS (omap_muxer_config_parser_parent_class)->finalize (obj);
}


GType omap_muxer_config_parser_get_type (void) {
	static volatile gsize omap_muxer_config_parser_type_id__volatile = 0;
	if (g_once_init_enter (&omap_muxer_config_parser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OmapMuxerConfigParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) omap_muxer_config_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OmapMuxerConfigParser), 0, (GInstanceInitFunc) omap_muxer_config_parser_instance_init, NULL };
		GType omap_muxer_config_parser_type_id;
		omap_muxer_config_parser_type_id = g_type_register_static (G_TYPE_OBJECT, "OmapMuxerConfigParser", &g_define_type_info, 0);
		g_once_init_leave (&omap_muxer_config_parser_type_id__volatile, omap_muxer_config_parser_type_id);
	}
	return omap_muxer_config_parser_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




