/* muxer-control.c generated by valac, the Vala compiler
 * generated from muxer-control.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gst/gst.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_CONTROL (control_get_type ())
#define CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONTROL, Control))
#define IS_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONTROL))
#define CONTROL_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_CONTROL, ControlIface))

typedef struct _Control Control;
typedef struct _ControlIface ControlIface;

#define TYPE_MUXER_CONTROL (muxer_control_get_type ())
#define MUXER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MUXER_CONTROL, MuxerControl))
#define MUXER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MUXER_CONTROL, MuxerControlClass))
#define IS_MUXER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MUXER_CONTROL))
#define IS_MUXER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MUXER_CONTROL))
#define MUXER_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MUXER_CONTROL, MuxerControlClass))

typedef struct _MuxerControl MuxerControl;
typedef struct _MuxerControlClass MuxerControlClass;
typedef struct _MuxerControlPrivate MuxerControlPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _gst_event_unref0(var) ((var == NULL) ? NULL : (var = (gst_event_unref (var), NULL)))

struct _ControlIface {
	GTypeInterface parent_iface;
	GstBus* (*get_bus) (Control* self);
};

struct _MuxerControl {
	GObject parent_instance;
	MuxerControlPrivate * priv;
	char* preview_desc;
	char* record_desc;
	gboolean recording;
	gboolean previewing;
	gboolean buffer_probe_enabled;
	GstElement* overlay;
	GstElement* tee;
	GstElement* audiosrc;
	GstBin* preview_bin;
	GstBin* record_bin;
	GstElement* queue;
	GstClockTime adjust_ts_video;
	GstClockTime adjust_ts_audio;
	guint video_probe_id;
	guint audio_probe_id;
};

struct _MuxerControlClass {
	GObjectClass parent_class;
};


static gpointer muxer_control_parent_class = NULL;
static ControlIface* muxer_control_control_parent_iface = NULL;

GType control_get_type (void);
GType muxer_control_get_type (void);
enum  {
	MUXER_CONTROL_DUMMY_PROPERTY
};
static GstBus* muxer_control_real_get_bus (Control* base);
void muxer_control_enable_buffer_probe (MuxerControl* self, gboolean enabled);
MuxerControl* muxer_control_new (const char* preview, const char* record);
MuxerControl* muxer_control_construct (GType object_type, const char* preview, const char* record);
void muxer_control_load_preview_pipeline (MuxerControl* self, GError** error);
void muxer_control_load (MuxerControl* self, GError** error);
gboolean muxer_control_is_previewing (MuxerControl* self);
gboolean muxer_control_is_recording (MuxerControl* self);
void muxer_control_start_preview (MuxerControl* self);
void muxer_control_stop_preview (MuxerControl* self);
void muxer_control_load_record_pipeline (MuxerControl* self, GError** error);
gboolean muxer_control_video_buffer_probe (MuxerControl* self, GstPad* pad, GstBuffer* buffer);
static gboolean _muxer_control_video_buffer_probe_gst_buffer_probe_callback (GstPad* pad, GstBuffer* buffer, gpointer self);
gboolean muxer_control_audio_buffer_probe (MuxerControl* self, GstPad* pad, GstBuffer* buffer);
static gboolean _muxer_control_audio_buffer_probe_gst_buffer_probe_callback (GstPad* pad, GstBuffer* buffer, gpointer self);
void muxer_control_start_record (MuxerControl* self, GError** error);
void muxer_control_stop_record (MuxerControl* self);
void muxer_control_on_bus_message (MuxerControl* self, GstMessage* message);
static void _muxer_control_on_bus_message_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self);
void muxer_control_shutdown (MuxerControl* self);
static void muxer_control_finalize (GObject* obj);


static void g_cclosure_user_marshal_VOID__POINTER_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);

static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


static GstBus* muxer_control_real_get_bus (Control* base) {
	MuxerControl * self;
	GstBus* result;
	self = (MuxerControl*) base;
	result = _gst_object_ref0 (((GstElement*) self->preview_bin)->bus);
	return result;
}


void muxer_control_enable_buffer_probe (MuxerControl* self, gboolean enabled) {
	g_return_if_fail (self != NULL);
	self->buffer_probe_enabled = enabled;
}


MuxerControl* muxer_control_construct (GType object_type, const char* preview, const char* record) {
	MuxerControl * self;
	char* _tmp0_;
	char* _tmp1_;
	g_return_val_if_fail (preview != NULL, NULL);
	g_return_val_if_fail (record != NULL, NULL);
	self = (MuxerControl*) g_object_new (object_type, NULL);
	self->preview_desc = (_tmp0_ = g_strdup (preview), _g_free0 (self->preview_desc), _tmp0_);
	self->record_desc = (_tmp1_ = g_strdup (record), _g_free0 (self->record_desc), _tmp1_);
	return self;
}


MuxerControl* muxer_control_new (const char* preview, const char* record) {
	return muxer_control_construct (TYPE_MUXER_CONTROL, preview, record);
}


void muxer_control_load (MuxerControl* self, GError** error) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	muxer_control_load_preview_pipeline (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
}


gboolean muxer_control_is_previewing (MuxerControl* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->previewing;
	return result;
}


gboolean muxer_control_is_recording (MuxerControl* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->recording;
	return result;
}


void muxer_control_start_preview (MuxerControl* self) {
	g_return_if_fail (self != NULL);
	if (gst_element_set_state ((GstElement*) self->preview_bin, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE) {
		self->previewing = TRUE;
	}
}


void muxer_control_stop_preview (MuxerControl* self) {
	g_return_if_fail (self != NULL);
	gst_element_set_state ((GstElement*) self->preview_bin, GST_STATE_NULL);
	self->previewing = FALSE;
}


static gboolean _muxer_control_video_buffer_probe_gst_buffer_probe_callback (GstPad* pad, GstBuffer* buffer, gpointer self) {
	return muxer_control_video_buffer_probe (self, pad, buffer);
}


static gboolean _muxer_control_audio_buffer_probe_gst_buffer_probe_callback (GstPad* pad, GstBuffer* buffer, gpointer self) {
	return muxer_control_audio_buffer_probe (self, pad, buffer);
}


void muxer_control_start_record (MuxerControl* self, GError** error) {
	GError * _inner_error_;
	GstPad* tee_src1_pad;
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	if (self->buffer_probe_enabled) {
		gst_element_set_state ((GstElement*) self->preview_bin, GST_STATE_PAUSED);
	} else {
		gst_element_set_state ((GstElement*) self->preview_bin, GST_STATE_NULL);
	}
	muxer_control_load_record_pipeline (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	gst_bin_add (self->preview_bin, _gst_object_ref0 ((GstElement*) self->record_bin));
	gst_element_link (self->tee, self->queue);
	tee_src1_pad = gst_element_get_static_pad (self->tee, "src1");
	if (self->buffer_probe_enabled) {
		self->video_probe_id = gst_pad_add_buffer_probe (tee_src1_pad, _muxer_control_video_buffer_probe_gst_buffer_probe_callback, self);
	}
	if (self->buffer_probe_enabled) {
		_tmp0_ = self->audiosrc != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GstPad* audio_src_pad;
		audio_src_pad = gst_element_get_static_pad (self->audiosrc, "src");
		self->audio_probe_id = gst_pad_add_buffer_probe (audio_src_pad, _muxer_control_audio_buffer_probe_gst_buffer_probe_callback, self);
		_gst_object_unref0 (audio_src_pad);
	}
	if (self->overlay != NULL) {
		g_object_set ((GObject*) self->overlay, "silent", FALSE, NULL);
	}
	if (gst_element_set_state ((GstElement*) self->preview_bin, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE) {
		self->recording = TRUE;
	}
	_gst_object_unref0 (tee_src1_pad);
}


void muxer_control_stop_record (MuxerControl* self) {
	GstBus* _tmp0_;
	g_return_if_fail (self != NULL);
	if (!self->recording) {
		return;
	}
	gst_element_set_state (self->tee, GST_STATE_PAUSED);
	if (self->overlay != NULL) {
		g_object_set ((GObject*) self->overlay, "silent", TRUE, NULL);
	}
	gst_element_unlink (self->tee, self->queue);
	gst_bin_remove (self->preview_bin, (GstElement*) self->record_bin);
	gst_element_set_bus ((GstElement*) self->record_bin, _tmp0_ = gst_element_get_bus ((GstElement*) self->preview_bin));
	_gst_object_unref0 (_tmp0_);
	gst_element_send_event (self->queue, gst_event_new_eos ());
	if (self->audiosrc != NULL) {
		gst_element_send_event (self->audiosrc, gst_event_new_eos ());
	}
	gst_element_set_state (self->tee, GST_STATE_PLAYING);
}


static void _muxer_control_on_bus_message_gst_bus_message (GstBus* _sender, GstMessage* message, gpointer self) {
	muxer_control_on_bus_message (self, message);
}


void muxer_control_load_preview_pipeline (MuxerControl* self, GError** error) {
	GError * _inner_error_;
	GstElement* _tmp0_;
	GstBin* _tmp2_;
	GstElement* _tmp1_;
	GstBus* bus;
	GstElement* _tmp3_;
	GstElement* _tmp4_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	_tmp0_ = gst_parse_launch (self->preview_desc, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	self->preview_bin = (_tmp2_ = (_tmp1_ = _tmp0_, GST_IS_BIN (_tmp1_) ? ((GstBin*) _tmp1_) : NULL), _gst_object_unref0 (self->preview_bin), _tmp2_);
	bus = gst_element_get_bus ((GstElement*) self->preview_bin);
	gst_bus_add_signal_watch (bus);
	g_signal_connect_object (bus, "message", (GCallback) _muxer_control_on_bus_message_gst_bus_message, self, 0);
	gst_object_set_name ((GstObject*) self->preview_bin, "preview_bin");
	self->overlay = (_tmp3_ = gst_bin_get_by_name (self->preview_bin, "overlay"), _gst_object_unref0 (self->overlay), _tmp3_);
	if ((self->tee = (_tmp4_ = gst_bin_get_by_name (self->preview_bin, "tee"), _gst_object_unref0 (self->tee), _tmp4_)) == NULL) {
		_inner_error_ = g_error_new_literal (GST_CORE_ERROR, GST_CORE_ERROR_FAILED, "No element named tee in the preview pipeline");
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			_gst_object_unref0 (bus);
			return;
		}
	}
	_gst_object_unref0 (bus);
}


void muxer_control_load_record_pipeline (MuxerControl* self, GError** error) {
	GError * _inner_error_;
	GstElement* _tmp0_;
	GstBin* _tmp2_;
	GstElement* _tmp1_;
	GstElement* _tmp3_;
	GstElement* _tmp4_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	_tmp0_ = gst_parse_launch (self->record_desc, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	self->record_bin = (_tmp2_ = (_tmp1_ = _tmp0_, GST_IS_BIN (_tmp1_) ? ((GstBin*) _tmp1_) : NULL), _gst_object_unref0 (self->record_bin), _tmp2_);
	gst_object_set_name ((GstObject*) self->record_bin, "record_bin");
	if ((self->queue = (_tmp3_ = gst_bin_get_by_name (self->record_bin, "queue"), _gst_object_unref0 (self->queue), _tmp3_)) == NULL) {
		_inner_error_ = g_error_new_literal (GST_CORE_ERROR, GST_CORE_ERROR_FAILED, "No element named queue in the record pipeline");
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			return;
		}
	}
	self->audiosrc = (_tmp4_ = gst_bin_get_by_name (self->record_bin, "audiosrc"), _gst_object_unref0 (self->audiosrc), _tmp4_);
}


void muxer_control_on_bus_message (MuxerControl* self, GstMessage* message) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	switch (message->type) {
		case GST_MESSAGE_EOS:
		{
			{
				gst_element_set_state ((GstElement*) self->record_bin, GST_STATE_NULL);
				self->recording = FALSE;
				g_signal_emit_by_name (self, "eos");
			}
			break;
		}
		case GST_MESSAGE_ERROR:
		{
			{
				GError* e;
				char* debug;
				char* _tmp3_;
				char* _tmp2_ = NULL;
				GError* _tmp1_;
				GError* _tmp0_ = NULL;
				e = NULL;
				debug = NULL;
				(gst_message_parse_error (message, &_tmp0_, &_tmp2_), e = (_tmp1_ = _tmp0_, _g_error_free0 (e), _tmp1_));
				debug = (_tmp3_ = _tmp2_, _g_free0 (debug), _tmp3_);
				g_signal_emit_by_name (self, "error", e, debug);
				muxer_control_shutdown (self);
				g_signal_emit_by_name (self, "eos");
				_g_error_free0 (e);
				_g_free0 (debug);
			}
			break;
		}
		default:
		{
			{
				;
			}
			break;
		}
	}
}


void muxer_control_shutdown (MuxerControl* self) {
	g_return_if_fail (self != NULL);
	muxer_control_stop_record (self);
	muxer_control_stop_preview (self);
}


static gpointer _gst_event_ref0 (gpointer self) {
	return self ? gst_event_ref (self) : NULL;
}


gboolean muxer_control_video_buffer_probe (MuxerControl* self, GstPad* pad, GstBuffer* buffer) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pad != NULL, FALSE);
	g_return_val_if_fail (buffer != NULL, FALSE);
	if (self->adjust_ts_video == 0) {
		GstObject* _tmp0_;
		GstElement* parent;
		GstPad* sinkpad;
		GstEvent* event;
		self->adjust_ts_video = buffer->timestamp;
		parent = (_tmp0_ = gst_object_get_parent ((GstObject*) pad), GST_IS_ELEMENT (_tmp0_) ? ((GstElement*) _tmp0_) : NULL);
		sinkpad = gst_element_get_static_pad (parent, "sink");
		event = gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME, (gint64) 0, (gint64) (-1), (gint64) 0);
		gst_pad_send_event (sinkpad, _gst_event_ref0 (event));
		((GstMiniObject*) buffer)->flags = ((GstMiniObject*) buffer)->flags | ((guint) GST_BUFFER_FLAG_DISCONT);
		_gst_object_unref0 (parent);
		_gst_object_unref0 (sinkpad);
		_gst_event_unref0 (event);
	}
	buffer->timestamp = buffer->timestamp - self->adjust_ts_video;
	result = TRUE;
	return result;
}


gboolean muxer_control_audio_buffer_probe (MuxerControl* self, GstPad* pad, GstBuffer* buffer) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pad != NULL, FALSE);
	g_return_val_if_fail (buffer != NULL, FALSE);
	if (self->adjust_ts_audio == 0) {
		GstPad* peerpad;
		GstEvent* event;
		self->adjust_ts_audio = buffer->timestamp;
		peerpad = gst_pad_get_peer (pad);
		event = gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME, (gint64) 0, (gint64) (-1), (gint64) 0);
		gst_pad_send_event (peerpad, _gst_event_ref0 (event));
		((GstMiniObject*) buffer)->flags = ((GstMiniObject*) buffer)->flags | ((guint) GST_BUFFER_FLAG_DISCONT);
		_gst_object_unref0 (peerpad);
		_gst_event_unref0 (event);
	}
	buffer->timestamp = buffer->timestamp - self->adjust_ts_audio;
	result = TRUE;
	return result;
}


static void muxer_control_class_init (MuxerControlClass * klass) {
	muxer_control_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = muxer_control_finalize;
	g_signal_new ("eos", TYPE_MUXER_CONTROL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("error", TYPE_MUXER_CONTROL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__POINTER_STRING, G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_STRING);
}


static void muxer_control_control_interface_init (ControlIface * iface) {
	muxer_control_control_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_bus = muxer_control_real_get_bus;
}


static void muxer_control_instance_init (MuxerControl * self) {
}


static void muxer_control_finalize (GObject* obj) {
	MuxerControl * self;
	self = MUXER_CONTROL (obj);
	{
		muxer_control_shutdown (self);
	}
	_g_free0 (self->preview_desc);
	_g_free0 (self->record_desc);
	_gst_object_unref0 (self->overlay);
	_gst_object_unref0 (self->tee);
	_gst_object_unref0 (self->audiosrc);
	_gst_object_unref0 (self->preview_bin);
	_gst_object_unref0 (self->record_bin);
	_gst_object_unref0 (self->queue);
	G_OBJECT_CLASS (muxer_control_parent_class)->finalize (obj);
}


GType muxer_control_get_type (void) {
	static GType muxer_control_type_id = 0;
	if (muxer_control_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (MuxerControlClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) muxer_control_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MuxerControl), 0, (GInstanceInitFunc) muxer_control_instance_init, NULL };
		static const GInterfaceInfo control_info = { (GInterfaceInitFunc) muxer_control_control_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		muxer_control_type_id = g_type_register_static (G_TYPE_OBJECT, "MuxerControl", &g_define_type_info, 0);
		g_type_add_interface_static (muxer_control_type_id, TYPE_CONTROL, &control_info);
	}
	return muxer_control_type_id;
}



static void g_cclosure_user_marshal_VOID__POINTER_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__POINTER_STRING) (gpointer data1, gpointer arg_1, const char* arg_2, gpointer data2);
	register GMarshalFunc_VOID__POINTER_STRING callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__POINTER_STRING) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_pointer (param_values + 1), g_value_get_string (param_values + 2), data2);
}



