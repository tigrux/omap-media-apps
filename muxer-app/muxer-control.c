/* muxer-control.c generated by valac, the Vala compiler
 * generated from muxer-control.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gst/gst.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_MEDIA_CONTROL (media_control_get_type ())
#define MEDIA_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MEDIA_CONTROL, MediaControl))
#define MEDIA_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MEDIA_CONTROL, MediaControlClass))
#define IS_MEDIA_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MEDIA_CONTROL))
#define IS_MEDIA_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MEDIA_CONTROL))
#define MEDIA_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MEDIA_CONTROL, MediaControlClass))

typedef struct _MediaControl MediaControl;
typedef struct _MediaControlClass MediaControlClass;
typedef struct _MediaControlPrivate MediaControlPrivate;

#define TYPE_MUXER_CONTROL (muxer_control_get_type ())
#define MUXER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MUXER_CONTROL, MuxerControl))
#define MUXER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MUXER_CONTROL, MuxerControlClass))
#define IS_MUXER_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MUXER_CONTROL))
#define IS_MUXER_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MUXER_CONTROL))
#define MUXER_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MUXER_CONTROL, MuxerControlClass))

typedef struct _MuxerControl MuxerControl;
typedef struct _MuxerControlClass MuxerControlClass;
typedef struct _MuxerControlPrivate MuxerControlPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _gst_object_unref0(var) ((var == NULL) ? NULL : (var = (gst_object_unref (var), NULL)))
#define _gst_event_unref0(var) ((var == NULL) ? NULL : (var = (gst_event_unref (var), NULL)))

struct _MediaControl {
	GObject parent_instance;
	MediaControlPrivate * priv;
	GstBus* bus;
	GstBin* pipeline;
};

struct _MediaControlClass {
	GObjectClass parent_class;
};

struct _MuxerControl {
	MediaControl parent_instance;
	MuxerControlPrivate * priv;
	char* preview_desc;
	char* record_desc;
	gboolean recording;
	gboolean previewing;
	gboolean buffer_probe_enabled;
	GstElement* overlay;
	GstElement* tee;
	GstElement* audiosrc;
	GstBin* preview_pipeline;
	GstBin* record_pipeline;
	GstElement* queue;
	GstClockTime adjust_ts_video;
	GstClockTime adjust_ts_audio;
	guint video_probe_id;
	guint audio_probe_id;
};

struct _MuxerControlClass {
	MediaControlClass parent_class;
};


static gpointer muxer_control_parent_class = NULL;

GType media_control_get_type (void);
GType muxer_control_get_type (void);
enum  {
	MUXER_CONTROL_DUMMY_PROPERTY
};
void muxer_control_enable_buffer_probe (MuxerControl* self, gboolean enabled);
MuxerControl* muxer_control_new (const char* preview, const char* record);
MuxerControl* muxer_control_construct (GType object_type, const char* preview, const char* record);
void muxer_control_load_preview_pipeline (MuxerControl* self, GError** error);
void muxer_control_load (MuxerControl* self, GError** error);
gboolean muxer_control_is_previewing (MuxerControl* self);
gboolean muxer_control_is_recording (MuxerControl* self);
void muxer_control_start_preview (MuxerControl* self);
void muxer_control_stop_preview (MuxerControl* self);
void muxer_control_load_record_pipeline (MuxerControl* self, GError** error);
gboolean muxer_control_video_buffer_probe (MuxerControl* self, GstPad* pad, GstBuffer* buffer);
static gboolean _muxer_control_video_buffer_probe_gst_buffer_probe_callback (GstPad* pad, GstBuffer* buffer, gpointer self);
gboolean muxer_control_audio_buffer_probe (MuxerControl* self, GstPad* pad, GstBuffer* buffer);
static gboolean _muxer_control_audio_buffer_probe_gst_buffer_probe_callback (GstPad* pad, GstBuffer* buffer, gpointer self);
void muxer_control_start_record (MuxerControl* self, GError** error);
void muxer_control_stop_record (MuxerControl* self);
void media_control_set_pipeline (MediaControl* self, GstBin* bin);
void muxer_control_on_eos (MuxerControl* self, GstObject* src);
void muxer_control_shutdown (MuxerControl* self);
void muxer_control_on_error (MuxerControl* self, GstObject* src, GError* e, const char* debug);
static void _muxer_control_on_error_media_control_error_message (MuxerControl* _sender, GstObject* src, GError* _error_, const char* debug, gpointer self);
static void _muxer_control_on_eos_media_control_eos_message (MuxerControl* _sender, GstObject* src, gpointer self);
static GObject * muxer_control_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void muxer_control_finalize (GObject* obj);



void muxer_control_enable_buffer_probe (MuxerControl* self, gboolean enabled) {
	g_return_if_fail (self != NULL);
	self->buffer_probe_enabled = enabled;
}


MuxerControl* muxer_control_construct (GType object_type, const char* preview, const char* record) {
	MuxerControl * self;
	char* _tmp0_;
	char* _tmp1_;
	g_return_val_if_fail (preview != NULL, NULL);
	g_return_val_if_fail (record != NULL, NULL);
	self = g_object_newv (object_type, 0, NULL);
	self->preview_desc = (_tmp0_ = g_strdup (preview), _g_free0 (self->preview_desc), _tmp0_);
	self->record_desc = (_tmp1_ = g_strdup (record), _g_free0 (self->record_desc), _tmp1_);
	return self;
}


MuxerControl* muxer_control_new (const char* preview, const char* record) {
	return muxer_control_construct (TYPE_MUXER_CONTROL, preview, record);
}


void muxer_control_load (MuxerControl* self, GError** error) {
	GError * _inner_error_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	muxer_control_load_preview_pipeline (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
}


gboolean muxer_control_is_previewing (MuxerControl* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->previewing;
	return result;
}


gboolean muxer_control_is_recording (MuxerControl* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->recording;
	return result;
}


void muxer_control_start_preview (MuxerControl* self) {
	g_return_if_fail (self != NULL);
	if (gst_element_set_state ((GstElement*) self->preview_pipeline, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE) {
		self->previewing = TRUE;
	}
}


void muxer_control_stop_preview (MuxerControl* self) {
	g_return_if_fail (self != NULL);
	gst_element_set_state ((GstElement*) self->preview_pipeline, GST_STATE_NULL);
	self->previewing = FALSE;
}


static gpointer _gst_object_ref0 (gpointer self) {
	return self ? gst_object_ref (self) : NULL;
}


static gboolean _muxer_control_video_buffer_probe_gst_buffer_probe_callback (GstPad* pad, GstBuffer* buffer, gpointer self) {
	return muxer_control_video_buffer_probe (self, pad, buffer);
}


static gboolean _muxer_control_audio_buffer_probe_gst_buffer_probe_callback (GstPad* pad, GstBuffer* buffer, gpointer self) {
	return muxer_control_audio_buffer_probe (self, pad, buffer);
}


void muxer_control_start_record (MuxerControl* self, GError** error) {
	GError * _inner_error_;
	GstPad* tee_src1_pad;
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	if (self->buffer_probe_enabled) {
		gst_element_set_state ((GstElement*) self->preview_pipeline, GST_STATE_PAUSED);
	} else {
		gst_element_set_state ((GstElement*) self->preview_pipeline, GST_STATE_NULL);
	}
	muxer_control_load_record_pipeline (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	gst_bin_add (self->preview_pipeline, _gst_object_ref0 ((GstElement*) self->record_pipeline));
	gst_element_link (self->tee, self->queue);
	tee_src1_pad = gst_element_get_static_pad (self->tee, "src1");
	if (self->buffer_probe_enabled) {
		self->video_probe_id = gst_pad_add_buffer_probe (tee_src1_pad, _muxer_control_video_buffer_probe_gst_buffer_probe_callback, self);
	}
	if (self->buffer_probe_enabled) {
		_tmp0_ = self->audiosrc != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GstPad* audio_src_pad;
		audio_src_pad = gst_element_get_static_pad (self->audiosrc, "src");
		self->audio_probe_id = gst_pad_add_buffer_probe (audio_src_pad, _muxer_control_audio_buffer_probe_gst_buffer_probe_callback, self);
		_gst_object_unref0 (audio_src_pad);
	}
	if (self->overlay != NULL) {
		g_object_set ((GObject*) self->overlay, "silent", FALSE, NULL);
	}
	if (gst_element_set_state ((GstElement*) self->preview_pipeline, GST_STATE_PLAYING) != GST_STATE_CHANGE_FAILURE) {
		self->recording = TRUE;
	}
	_gst_object_unref0 (tee_src1_pad);
}


void muxer_control_stop_record (MuxerControl* self) {
	GstBus* _tmp0_;
	g_return_if_fail (self != NULL);
	if (!self->recording) {
		return;
	}
	gst_element_set_state (self->tee, GST_STATE_PAUSED);
	if (self->overlay != NULL) {
		g_object_set ((GObject*) self->overlay, "silent", TRUE, NULL);
	}
	gst_element_unlink (self->tee, self->queue);
	gst_bin_remove (self->preview_pipeline, (GstElement*) self->record_pipeline);
	gst_element_set_bus ((GstElement*) self->record_pipeline, _tmp0_ = gst_element_get_bus ((GstElement*) self->preview_pipeline));
	_gst_object_unref0 (_tmp0_);
	gst_element_send_event (self->queue, gst_event_new_eos ());
	if (self->audiosrc != NULL) {
		gst_element_send_event (self->audiosrc, gst_event_new_eos ());
	}
	gst_element_set_state (self->tee, GST_STATE_PLAYING);
}


void muxer_control_load_preview_pipeline (MuxerControl* self, GError** error) {
	GError * _inner_error_;
	GstElement* _tmp0_;
	GstBin* _tmp2_;
	GstElement* _tmp1_;
	GstElement* _tmp3_;
	GstElement* _tmp4_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	_tmp0_ = gst_parse_launch (self->preview_desc, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	self->preview_pipeline = (_tmp2_ = (_tmp1_ = _tmp0_, GST_IS_BIN (_tmp1_) ? ((GstBin*) _tmp1_) : NULL), _gst_object_unref0 (self->preview_pipeline), _tmp2_);
	gst_object_set_name ((GstObject*) self->preview_pipeline, "preview_pipeline");
	media_control_set_pipeline ((MediaControl*) self, self->preview_pipeline);
	self->overlay = (_tmp3_ = gst_bin_get_by_name (self->preview_pipeline, "overlay"), _gst_object_unref0 (self->overlay), _tmp3_);
	if ((self->tee = (_tmp4_ = gst_bin_get_by_name (self->preview_pipeline, "tee"), _gst_object_unref0 (self->tee), _tmp4_)) == NULL) {
		_inner_error_ = g_error_new_literal (GST_CORE_ERROR, GST_CORE_ERROR_FAILED, "No element named tee in the preview pipeline");
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			return;
		}
	}
}


void muxer_control_load_record_pipeline (MuxerControl* self, GError** error) {
	GError * _inner_error_;
	GstElement* _tmp0_;
	GstBin* _tmp2_;
	GstElement* _tmp1_;
	GstElement* _tmp3_;
	GstElement* _tmp4_;
	g_return_if_fail (self != NULL);
	_inner_error_ = NULL;
	_tmp0_ = gst_parse_launch (self->record_desc, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return;
	}
	self->record_pipeline = (_tmp2_ = (_tmp1_ = _tmp0_, GST_IS_BIN (_tmp1_) ? ((GstBin*) _tmp1_) : NULL), _gst_object_unref0 (self->record_pipeline), _tmp2_);
	gst_object_set_name ((GstObject*) self->record_pipeline, "record_pipeline");
	if ((self->queue = (_tmp3_ = gst_bin_get_by_name (self->record_pipeline, "queue"), _gst_object_unref0 (self->queue), _tmp3_)) == NULL) {
		_inner_error_ = g_error_new_literal (GST_CORE_ERROR, GST_CORE_ERROR_FAILED, "No element named queue in the record pipeline");
		if (_inner_error_ != NULL) {
			g_propagate_error (error, _inner_error_);
			return;
		}
	}
	self->audiosrc = (_tmp4_ = gst_bin_get_by_name (self->record_pipeline, "audiosrc"), _gst_object_unref0 (self->audiosrc), _tmp4_);
}


void muxer_control_on_eos (MuxerControl* self, GstObject* src) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (src != NULL);
	gst_element_set_state ((GstElement*) self->record_pipeline, GST_STATE_NULL);
	self->recording = FALSE;
}


void muxer_control_on_error (MuxerControl* self, GstObject* src, GError* e, const char* debug) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (src != NULL);
	g_return_if_fail (debug != NULL);
	muxer_control_shutdown (self);
}


void muxer_control_shutdown (MuxerControl* self) {
	g_return_if_fail (self != NULL);
	muxer_control_stop_record (self);
	muxer_control_stop_preview (self);
}


static gpointer _gst_event_ref0 (gpointer self) {
	return self ? gst_event_ref (self) : NULL;
}


gboolean muxer_control_video_buffer_probe (MuxerControl* self, GstPad* pad, GstBuffer* buffer) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pad != NULL, FALSE);
	g_return_val_if_fail (buffer != NULL, FALSE);
	if (self->adjust_ts_video == 0) {
		GstObject* _tmp0_;
		GstElement* parent;
		GstPad* sinkpad;
		GstEvent* event;
		self->adjust_ts_video = buffer->timestamp;
		parent = (_tmp0_ = gst_object_get_parent ((GstObject*) pad), GST_IS_ELEMENT (_tmp0_) ? ((GstElement*) _tmp0_) : NULL);
		sinkpad = gst_element_get_static_pad (parent, "sink");
		event = gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME, (gint64) 0, (gint64) (-1), (gint64) 0);
		gst_pad_send_event (sinkpad, _gst_event_ref0 (event));
		((GstMiniObject*) buffer)->flags = ((GstMiniObject*) buffer)->flags | ((guint) GST_BUFFER_FLAG_DISCONT);
		_gst_object_unref0 (parent);
		_gst_object_unref0 (sinkpad);
		_gst_event_unref0 (event);
	}
	buffer->timestamp = buffer->timestamp - self->adjust_ts_video;
	result = TRUE;
	return result;
}


gboolean muxer_control_audio_buffer_probe (MuxerControl* self, GstPad* pad, GstBuffer* buffer) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (pad != NULL, FALSE);
	g_return_val_if_fail (buffer != NULL, FALSE);
	if (self->adjust_ts_audio == 0) {
		GstPad* peerpad;
		GstEvent* event;
		self->adjust_ts_audio = buffer->timestamp;
		peerpad = gst_pad_get_peer (pad);
		event = gst_event_new_new_segment (FALSE, 1.0, GST_FORMAT_TIME, (gint64) 0, (gint64) (-1), (gint64) 0);
		gst_pad_send_event (peerpad, _gst_event_ref0 (event));
		((GstMiniObject*) buffer)->flags = ((GstMiniObject*) buffer)->flags | ((guint) GST_BUFFER_FLAG_DISCONT);
		_gst_object_unref0 (peerpad);
		_gst_event_unref0 (event);
	}
	buffer->timestamp = buffer->timestamp - self->adjust_ts_audio;
	result = TRUE;
	return result;
}


static void _muxer_control_on_error_media_control_error_message (MuxerControl* _sender, GstObject* src, GError* _error_, const char* debug, gpointer self) {
	muxer_control_on_error (self, src, _error_, debug);
}


static void _muxer_control_on_eos_media_control_eos_message (MuxerControl* _sender, GstObject* src, gpointer self) {
	muxer_control_on_eos (self, src);
}


static GObject * muxer_control_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	MuxerControl * self;
	parent_class = G_OBJECT_CLASS (muxer_control_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = MUXER_CONTROL (obj);
	{
		g_signal_connect_object ((MediaControl*) self, "error-message", (GCallback) _muxer_control_on_error_media_control_error_message, self, 0);
		g_signal_connect_object ((MediaControl*) self, "eos-message", (GCallback) _muxer_control_on_eos_media_control_eos_message, self, 0);
	}
	return obj;
}


static void muxer_control_class_init (MuxerControlClass * klass) {
	muxer_control_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = muxer_control_constructor;
	G_OBJECT_CLASS (klass)->finalize = muxer_control_finalize;
}


static void muxer_control_instance_init (MuxerControl * self) {
}


static void muxer_control_finalize (GObject* obj) {
	MuxerControl * self;
	self = MUXER_CONTROL (obj);
	{
		muxer_control_shutdown (self);
	}
	_g_free0 (self->preview_desc);
	_g_free0 (self->record_desc);
	_gst_object_unref0 (self->overlay);
	_gst_object_unref0 (self->tee);
	_gst_object_unref0 (self->audiosrc);
	_gst_object_unref0 (self->preview_pipeline);
	_gst_object_unref0 (self->record_pipeline);
	_gst_object_unref0 (self->queue);
	G_OBJECT_CLASS (muxer_control_parent_class)->finalize (obj);
}


GType muxer_control_get_type (void) {
	static GType muxer_control_type_id = 0;
	if (muxer_control_type_id == 0) {
		static const GTypeInfo g_define_type_info = { sizeof (MuxerControlClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) muxer_control_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MuxerControl), 0, (GInstanceInitFunc) muxer_control_instance_init, NULL };
		muxer_control_type_id = g_type_register_static (TYPE_MEDIA_CONTROL, "MuxerControl", &g_define_type_info, 0);
	}
	return muxer_control_type_id;
}




